\documentclass[10pt,a4paper]{article}
\usepackage{fullpage}

\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}

\newenvironment{definition}[1]{
	\paragraph{ 	
		\textcolor{green}{
			\underline{ \textcolor{black}{Définition : #1}} } }	} {}

\newenvironment{thm}[1]{
	\paragraph{ 	
		\textcolor{red}{
			\underline{ \textcolor{black}{Théorème : #1}} } } } {}
\newenvironment{rem}[1]{
	\subparagraph{ 	
		\textcolor{blue}{
			\underline{ \textcolor{black}{Remarque : #1}} } } } {}
\newenvironment{dem}[1]{
	\paragraph{ 	
		\textcolor{yellow}{
			\underline{ \textcolor{black}{Démonstration : #1}} } }} {}		
\newenvironment{lem}[1]{
	\subparagraph{ 	
		\textcolor{magenta}{
			\underline{ \textcolor{black}{Lemme : #1}} } } } {}		
\newenvironment{ex}[1]{
	\subparagraph{ 	
		\textcolor{magenta}{
			\underline{ \textcolor{black}{Exemple : #1}} } }} {}
\newenvironment{prop}[1]{
	\subparagraph{ 	
		\textcolor{cyan}{
			\underline{ \textcolor{black}{Proposition : #1}} } }} {}
\newenvironment{propriete}[1]{
	\subparagraph{ 	
		\textcolor{magenta}{
			\underline{ \textcolor{black}{Propriété : #1}} } }	} {}
			
				
\title{Sémantique}
\newcommand{\sem}[1]{$\left[| #1 | \right]$}
\newcommand{\semm}[1]{\left[| #1 | \right]}
\newcommand{\V}{\mathbb{V}}
\newcommand{\Z}{\mathbb{Z}}
\begin{document}
\part{Introduction}
\section{Compositionnalité}

La sémantique \sem{\cdot} est compositionnelle si \sem{P} se définit en fonction (par composition) des éléments composant $P$.\\
ex : \sem{A;B} = \sem{;}(\sem{A},\sem{B}\\
Reflète la structure syntaxique des programmes

La compositionnalité est indipensable pour avoir une sémantique utilisable;
Elle est parfois difficile à obtenir ( branchements, exceptions )



\section{Equivalence}
$P \sim Q ?$ : on veut une relation d'équivalence
$\semm{P} = \semm{Q} \rightarrow$ quelle déf pour \sem{P} ?\\

Si \sem{P} est l'ensemble des suites d'états visités par une exécution, $P \simeq Q$ si toutes les étapes d'éxcution de P et Q sont identiques.

Si \sem{P} = ensemble des suites d'états (...) avec certaines transitions marqués comme observables, $P \sim Q$ ssi les séquences de \sem{P} limités aux transitions observables sont les mêmes que celles de \sem{Q}

Si \sem{P} = états finaux des transitions de P, $P \sim Q$ si P et Q ont les mêmes ensembles d'états finaux

\subsection{Equivalence contextuelle}
$P \sim Q$ si $\semm{\mathcal{C}(P)} = \semm{\mathcal{C}(Q)}$
\begin{propriete}{compostionnalité}
$\semm P = \semm Q  \Rightarrow P \sim Q$
\end{propriete}
\paragraph{Biblio}
The formal semantic of programming languages

\part{Sémantique opérationnelle}

\subparagraph*{But} : formaliser les étapes de l'exécution d'un programme.

\section{Syntaxe}
Le language WHILE (IMP, TOY, ...) : mini language impératif.
\begin{itemize}
\item variables entières : $\mathbb{V}$
\item expressions arithmétiques sur entiers : \\
Aexp $ a := n \vert x \vert a_1 + a_2 \vert ...$
\item expressions booléennes : \\
Bexp $ b := true | false | a_1 = a_2 | a_1 > a_2 | ... | b_1 and b_2 | ...$
\item commandes : \\
Com $c := skip \vert x := a | c1; c2 |$ if $b$ then $c_1$ else $c_2$ $|$ while $b$ do $c$
\item Prog \\
$Prog = Com$ $P := c$
\item égalité syntaxique : \\
$c_1 \equiv c_2$ ($x := 2 \neq x := 1 + 1$)
\end{itemize}

\section{Sémantique des expressions}
\subparagraph*{} Sens attaché à une expression, valeur
\begin{itemize}
\item valeur des constantes : facile
\item valeur des variables : environnement \\
	$Env = \mathbb{V}\longrightarrow\mathbb{Z}$\\
	$ \sigma \in Etat = Env$ 
\item valeur attachée à la variable x dans l'état $\sigma : \sigma(x) \left( \in \mathbb{Z} \right)$
\item modifier un état : $\sigma ' = \sigma[x \leftarrow v]$ avec $v \in \mathbb{Z}$
\item sémantique des expressions : évalutation dirigée par la syntaxe
	\begin{itemize}
		\item $ <a, \sigma > \rightarrow n$ 
		\item $ <n, \sigma > \rightarrow n$						axiomes
		\item $ <x, \sigma > \rightarrow \sigma(x)$
		\item $\displaystyle \frac{ <a_1, \sigma > \rightarrow n_1 ; <a_2, \sigma > \rightarrow n_2}{<a_1 + a_2, \sigma > \rightarrow n_1 \pm n_2}$
	\end{itemize}
La sémantique n'est pas l'arbre d'évaluation d'une expression, mais sa conclusion (racine).
	\item sémantique des expressions booléennes
		\begin{itemize}
			\item $<True, \sigma > \rightarrow tt$
			\item $<a_1 = a_2,  \sigma > \rightarrow tt$ si $a_1 = a_2$, $ff$ sinon
		\end{itemize}
\end{itemize}
\begin{definition}{Equivalence sémnatique :}
$a_1 \sim a_2$ ssi pour tout $\sigma, n_1, n_2, (<a_1, \sigma> \rightarrow n_1$ et $<a_2, \sigma> \rightarrow n_2 ) \Rightarrow n_1 = n_2$
\end{definition}
\section{Sémantique des commandes}

\begin{definition}{Système de transitions} Un système de transitions est un triplet $(\Gamma, \Gamma_f, \rightarrow )$ \begin{itemize}
\item $\Gamma$ est un ensemble de configurations
\item $\Gamma_f$ est un ensemble de configurations finales
\item $\rightarrow \subseteq \Gamma \times (\Gamma \bigcup \Gamma_f )$ est une relation de transition $\Leftrightarrow$
$(\gamma, \gamma' ) \in \rightarrow$ : il existe une transition possible de $\gamma$ à $\gamma'$.
\end{itemize}
\end{definition}
On va avoir deux types de Transitions: \begin{itemize}
\item petits pas (SOS)
\item grands pas (SN)
\end{itemize}

\subsection{SOS : Structured operationnal semantic}
notation : $\sigma_i ~ x \mapsto i

\Gamma = Prog \times Etat

\Gamma_f = Etat$

Transitions de la forme : $<c, \sigma> \rightarrow <c', \sigma'>$ ou bien $<c, \sigma> \rightarrow \sigma'$\\
\begin{itemize}


\item $\displaystyle \overline{ <skip, \sigma > \rightarrow <\sigma> }$
\item $\displaystyle\frac{<a, \sigma > \rightarrow n }{ < x := \alpha , \sigma > \rightarrow \sigma [x \leftarrow n ] }$
\item $\displaystyle \frac{ <c, \sigma > \rightarrow \sigma' }{  < c; c' , \sigma > \rightarrow <c', \sigma'> }$
\item $\displaystyle \frac{< c, \sigma \rightarrow <c'', \sigma''>}{ <c; c', \sigma > \rightarrow <c''; c', \sigma'' > }$
\item $\displaystyle \frac{ <b, \sigma> \rightarrow tt }{\text{ if b then }  c_1\text{ else }c_2> \rightarrow <c_1, \sigma > }$
\item while : \\
 solution 1 : $\displaystyle \overline{ < \text{while b do c}, \sigma > \rightarrow < \text{if b then c; while b do c else }skip, \sigma > }$\\
 
solution 2 : $\displaystyle \frac{ < b, \sigma > \rightarrow \text{ff}}{ < \text{while b do c}, \sigma > \rightarrow \sigma }$
\item $\displaystyle  \frac{ < b, \sigma > \rightarrow \text{tt}}{ < \text{while b do c}, \sigma > \rightarrow <c;\text{while b do c}, \sigma >}$
\end{itemize}

Vocabulaire : 
\begin{definition}{Calcul} un calcul de c à partir de $\sigma$ est une suite finie ou infinie 
$\tau = \semm{c, \sigma} \rightarrow \gamma_1 \rightarrow \gamma_2 \rightarrow \dotsc \rightarrow \gamma_i \rightarrow \dotsc$\\
Le calcul :\begin{itemize}
\item boucle si la suite est infinie
\item termine si la suite est finie et que sa dernière configuration est finale.
\item est maximal s'il ne peut pas \^etre préfixe d'un autre calcul (soit il termine, soit il boucle, soit on ne plus faire de transition)
\end{itemize}
\end{definition}

\begin{thm}{}Étant donnés c et $\sigma$, SOS détermine un unique calcul maximal à partir de $<c, \sigma >$\\
 $\rightarrow$ SOS est déterministe
 \end{thm}
 
 
 Equivalence : 
$ c \sim_{SOS} c'$ ssi $\forall \sigma$, le calcul maximal issu de \sem{c , \sigma} est  identique au calcul maximal issu de \sem{c', \sigma}

Notion de résultat:\\
\begin{thm}{} soit $(\gamma_i)$ un calcul maximal à partir de $\gamma_0 = \sem{c, \sigma }$
\begin{enumerate}
\item soit $(\gamma_i)$ est infinie
\item soit $(\gamma_i )$ est finie, de longueur $n$, et $\gamma_{n-1} = \sigma' \in Etat$
\end{enumerate}
Dans le cas 1, on pose $\semm{ c }_{res} \sigma = \perp$\\
Dans le cas 2, on pose $\semm{ c }_{res} \sigma  = \sigma'$
\end{thm}


On étends $Etat_{\perp} = (\V \rightarrow \Z) \cup \{ \perp \}$
[| c |]_res est une fonction de $Etat$ dans $Etat_{\perp}$
rem : c'est une définition non effective (fonction non calculable)

Equivalence de résultat:
\begin{definition}{} $c \sim c'$ ssi $\forall \sigma, \semm{ c }_{res} \sigma = \semm{ c }_{res} \sigma$
(soit c et c' bouclent, soit elles convergent vers le m\^eme état final
\end{definition}
ex : tmp := y ; y := x; x := tmp $\notequiv$ aux := y; y := x ; x := aux

Equivalence modulo V
\begin{definition}{} $V \in \V$
$c \sim^V_{res}$ ssi $\forall \sigma [| c |]_res \sigma \sim^V [| c' |]_res \sigma$
avec $\sigma_1 \sim^V \sigma_2$ ssi \begin{itemize}
\item $\sigma_1 = \perp$ et $\sigma_2 = \perp$
\item ou  $\forall x in V, \sigma_1(x) = \sigma_2(x)$
\end{itemize}
\end{definition}

$\semm{skip}_{res} = id_{Etat}$
$\semm{ x := a }_{res} \sigma = \sigma [ x \leftarrow \semm{a} \sigma ]$
$\semm{c_1, c_2 }_{res} \sigma = \semm{c_2 }_{res} (\semm{c_1}_{res} \sigma)$ si on pose  $\semm{c}_{res} \perp = \perp$ pour tout c
$\semm{c_1, c_2 }_{res} = \semm{c_2 }_{res} \circ \semm{c_1}_{res}$ : compostion de fonctions
$\semm{\text{if b then }c_1\text{ else }c_2 } \sigma =$ si $\sigma \neq \perp :$
si$ \semm{b} \sigma = tt$ alors $\semm{c_1}_{res} \sigma$ sinon  $\semm{c_2}_{res} \sigma$
sinon $\perp$
$\semm{\text{ while b do c} } \sigma=$ si $\sigma = \perp$ alors $\perp$, sinon 
si $\semm{b}\sigma = tt$ alors $(\semm{while b do c } \circ \semm{c}) \sigma$, sinon $\sigma$)
def récursive ???

Quelques équivalences:
c; skip \sim_{res} c \sim_{res} skip; c " skip est neutre pour ;"
c; loop \sim_{res} loop \sim_{res} loop; c "loop est absorbant pour ;"
(c_1; c_2); c_3 \sim_{res} c_1; (c_2;c_3)  " ; est associatif"
 "; n'est pas commutatif"
 
 \subsection{Sémantique naturelle (SN)}
 
 Sémantique à "grands pas".
 Relation de transition \Rightarrow \subseteq (Prog \times Etat) \times Etat
\overline{ <skip, \sigma > \Rightarrow \sigma }
\overline{  <x:=a , \sigma > \Rightarrow \sigma [ x \leftarrow \semm{c } \sigma ] }
\frac{ <c_1, \sigma > , <c_2 , \sigma' > \Rightarrow \sigma'' }{<c_1, c_2, \sigma > \Rightarrow \sigma''}

On construit un arbre au lieu de construire une suite.
Def : une exécution de c à partir de \sigma est un arbre de dérivation dont la racine est de la forme <c, \sigma > \Rightarrow \sigma'

Rem : avec cette définition, une exécution termine toujours. Par abus de language, on dira que l'exécution boucle si l'arbre n'existe pas.

Equivalence : c \sim_{SN} c' ssi pour tout \sigma, \sigma', < c, \sigma > \Rightarrow ssi <c', \sigma > \Rightarrow \sigma'


\end{document}
