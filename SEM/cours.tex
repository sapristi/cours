\documentclass[10pt,a4paper]{article}
\usepackage{fullpage}
\usepackage[french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{array}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{stmaryrd}

%\hypersetup{colorlinks, linkcolor=black, urlcolor=black,%
%pdfauthor={Jean Dupond},%
%pdftitle={{Magnifique et splendide titre}},%
%pdfsubject={{Titre ou sous-titre}},%
%pdfcreator={LaTeX},%
%}	 
\usepackage{concrete}
 


\title{Sémantique}
\date{}

\newcommand{\E}{\mathcal{E}}

\newcommand{\sem}[1]{$\llbracket #1 \rrbracket$}
\newcommand{\semm}[1]{\llbracket #1 \rrbracket }
\newcommand{\semd}[1]{\mathcal{C} \semm{#1}}
\newcommand{\semh}[3]{\{#1\}#2\{#3\}}


\newcommand{\Vs}{\mathbb{V}}
\newcommand{\Ps}{\mathbb{P}}
\newcommand{\Fs}{\mathbb{F}}

\newcommand{\T}{\mathcal{T}}

\input{../nthmdefs}

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\openbullet$}
\renewcommand{\labelitemiii}{$\openbullet$}
\renewcommand{\labelitemiv}{$\openbullet$}

\begin{document}

\makeatletter
\@addtoreset{section}{part}
\makeatother

\maketitle


\begin{center}
\begin{tabular}{c c c}
opérationnelle & dénotationnelle & axiomatique \\
$\downarrow$ &  $\downarrow$ &  $\downarrow$ \\
chaque instruction & le résultat & une propriété \\
\end{tabular}
\end{center}



\part{Introduction}
\section{Compositionnalité}

\begin{definition}[Compositionnalité]
 La sémantique \sem{\cdot} est compositionnelle si \sem{P} se définit en fonction (par composition) des éléments constituant $P$.
\end{definition}

ex : \sem{A;B} = \sem{;}(\sem{A},\sem{B})\\

\begin{tabular}{l l}
La compositionnalité : & reflète la structure syntaxique des programmes.\\
& est indipensable pour avoir une sémantique utilisable;\\
& est parfois difficile à obtenir ( branchements, exceptions )
\end{tabular}


\section{Equivalence}
$P \sim Q ?$ : on veut une relation d'équivalence
$\semm{P} = \semm{Q} \rightarrow$ quelle déf pour \sem{P} ?\\
\begin{itemize}
\item Si \sem{P} est l'ensemble des suites d'états visités par une exécution, $P \simeq Q$ si toutes les étapes d'éxcution de P et Q sont identiques.
\item Si \sem{P} est l'ensemble des suites d'états (...) avec certaines transitions marquées comme observables, $P \sim Q$ ssi les séquences de \sem{P} limités aux transitions observables sont les mêmes que celles de \sem{Q}.
\item Si \sem{P} est l'ensemble des états finaux des transitions de P, $P \sim Q$ si P et Q ont les mêmes ensembles d'états finaux.
\end{itemize}
\subsection{Equivalence contextuelle}
$P \sim Q$ si $\semm{\mathcal{C}(P)} = \semm{\mathcal{C}(Q)}$
\begin{propriete}[Compostionnalité] 
$\semm{P} = \semm{Q}  \Rightarrow P \sim Q$
\end{propriete}
\paragraph{Biblio} :
The formal semantic of programming languages

\part{Sémantique opérationnelle}

\subparagraph{But} : formaliser les étapes de l'exécution d'un programme.

\section{Syntaxe}
Le language WHILE (IMP, TOY, ...) : mini language impératif.
\begin{itemize}
\item variables entières : $\mathbb{V}$
\item expressions arithmétiques sur entiers : \\
Aexp $ a := n \vert x \vert a_1 + a_2 \vert ...$
\item expressions booléennes : \\
Bexp $ b := true | false | a_1 = a_2 | a_1 > a_2 | ... | b_1 and b_2 | ...$
\item commandes : \\
Com $c := skip \vert x := a | c1; c2 |$ if $b$ then $c_1$ else $c_2$ $|$ while $b$ do $c$
\item Prog \\
$Prog = Com$ $P := c$
\item égalité syntaxique : \\
$c_1 \equiv c_2$ ($x := 2 \neq x := 1 + 1$)
\end{itemize}

\section{Sémantique des expressions}
\subparagraph*{} Sens attaché à une expression, valeur
\begin{itemize}
\item valeur des constantes : facile
\item valeur des variables : environnement \\
	$Env = \mathbb{V}\longrightarrow\mathbb{Z}$\\
	$ \sigma \in Etat = Env$ 
\item valeur attachée à la variable x dans l'état $\sigma : \sigma(x) \left( \in \mathbb{Z} \right)$
\item modifier un état : $\sigma ' = \sigma[x \leftarrow v]$ avec $v \in \mathbb{Z}$
\item sémantique des expressions : évalutation dirigée par la syntaxe\\
	\begin{itemize}
		\item $ <a, \sigma > \rightarrow n$ \\
		\item $ <n, \sigma > \rightarrow n$	\\
		\item $ <x, \sigma > \rightarrow \sigma(x)$\\
		\item $\displaystyle \frac{ <a_1, \sigma > \rightarrow n_1 ; <a_2, \sigma > \rightarrow n_2}{<a_1 + a_2, \sigma > \rightarrow n_1 \pm n_2}$\\
	\end{itemize}
\noindent La sémantique n'est pas l'arbre d'évaluation d'une expression, mais sa conclusion (racine).
	\item sémantique des expressions booléennes
		\begin{itemize}
			\item $<True, \sigma > \rightarrow tt$
			\item $<a_1 = a_2,  \sigma > \rightarrow tt$ si $a_1 = a_2$, $ff$ sinon
		\end{itemize}
\end{itemize}
\begin{definition}[Equivalence sémantique] 
$a_1 \sim a_2$ ssi pour tout $\sigma, n_1, n_2,\\ (<a_1, \sigma> \rightarrow n_1$ et $<a_2, \sigma> \rightarrow n_2 ) \Rightarrow n_1 = n_2$.
\end{definition}
\section{Sémantique des commandes}

\begin{definition}[Système de transitions] Un système de transitions est un triplet $(\Gamma, \Gamma_f, \rightarrow )$ où :\begin{itemize}
\item $\Gamma$ est un ensemble de configurations
\item $\Gamma_f$ est un ensemble de configurations finales
\item $\rightarrow \; \subseteq \; \Gamma \times (\Gamma \bigcup \Gamma_f )$ est une relation de transition: \\
$(\gamma, \gamma' )\; \in \;\rightarrow$ ssi il existe une transition possible de $\gamma$ à $\gamma'$.
\end{itemize}
\end{definition}

On va avoir deux types de transitions: \begin{itemize}
\item petits pas (SOS)
\item grands pas (SN)
\end{itemize}

\subsection{SOS : Structured operationnal semantic}
\noindent Notation : $\sigma_i ~ x \mapsto i\\
\Gamma = Prog \times Etat\\
\Gamma_f = Etat$

\noindent Transitions de la forme : $<c, \sigma> \rightarrow <c', \sigma'>$ ou bien $<c, \sigma> \rightarrow \sigma'$\\
\begin{itemize}


\item $\displaystyle \overline{ <skip, \sigma > \rightarrow <\sigma> }$\\
\item $\displaystyle\frac{<a, \sigma > \rightarrow n }{ < x := \alpha , \sigma > \rightarrow \sigma [x \leftarrow n ] }$\\
\item $\displaystyle \frac{ <c, \sigma > \rightarrow \sigma' }{  < c; c' , \sigma > \rightarrow <c', \sigma'> }$\\
\item $\displaystyle \frac{< c, \sigma \rightarrow <c'', \sigma''>}{ <c; c', \sigma > \rightarrow <c''; c', \sigma'' > }$\\
\item $\displaystyle \frac{ <b, \sigma> \rightarrow tt }{<\text{ if b then }  c_1\text{ else }c_2> \rightarrow <c_1, \sigma > }$\\
\item while : \begin{itemize}


 \item solution 1 : $\displaystyle \overline{ < \text{while b do c}, \sigma > \rightarrow < \text{if b then c; while b do c else }skip, \sigma > }$\\
 
\item solution 2 : $\displaystyle \frac{ < b, \sigma > \rightarrow \text{ff}}{ < \text{while b do c}, \sigma > \rightarrow \sigma }$\\

$\displaystyle  \frac{ < b, \sigma > \rightarrow \text{tt}}{ < \text{while b do c}, \sigma > \rightarrow <c;\text{while b do c}, \sigma >}$\\
\end{itemize}
\end{itemize}

\begin{definition}[Calcul] Un calcul de c à partir de $\sigma$ est une suite finie ou infinie 
$\tau = \semm{c, \sigma} \rightarrow \gamma_1 \rightarrow \gamma_2 \rightarrow \dotsc \rightarrow \gamma_i \rightarrow \dotsc$.\\
Le calcul :\begin{itemize}
\item boucle si la suite est infinie
\item termine si la suite est finie et que sa dernière configuration est finale.
\item est maximal s'il ne peut pas \^etre préfixe d'un autre calcul (soit il termine, soit il boucle, soit on ne plus faire de transition)
\end{itemize}
\end{definition}

\begin{thm}Étant donnés c et $\sigma$, SOS détermine un unique calcul maximal à partir de $<c, \sigma >$.\\
 $\rightarrow$ SOS est déterministe.\\
 \end{thm}
 
 \begin{definition}[Equivalence]
 $ c \sim_{SOS} c'$ ssi $\forall \sigma$, le calcul maximal issu de \sem{c , \sigma} est  identique au calcul maximal issu de \sem{c', \sigma}.
 \end{definition}
 


\paragraph*{Notion de résultat:}
\begin{thm} Soit $(\gamma_i)$ un calcul maximal à partir de $\gamma_0 = \semm{c, \sigma }$
\begin{enumerate}
\item soit $(\gamma_i)$ est infinie
\item soit $(\gamma_i )$ est finie, de longueur $n$, et $\gamma_{n-1} = \sigma' \in Etat$
\end{enumerate}
Dans le cas 1, on pose $\semm{ c }_{res} \sigma = \perp$\\
Dans le cas 2, on pose $\semm{ c }_{res} \sigma  = \sigma'$\\
\end{thm}


On étends $Etat_{\perp} = (\Vs \rightarrow \Zs) \cup \{ \perp \}$
$\semm{ c }_{res}$ est une fonction de $Etat$ dans $Etat_{\perp}$
\begin{rem} c'est une définition non effective (fonction non calculable)
\end{rem}


\paragraph{Equivalence de résultat:}
\begin{definition} $c \sim c'$ ssi $\forall \sigma, \; \semm{ c }_{res} \sigma = \semm{ c }_{res} \sigma$\\
(soit c et c' bouclent, soit elles convergent vers le même état final.)
\end{definition}

ex : tmp := y ; y := x; x := tmp $\not \equiv$ aux := y; y := x ; x := aux


\begin{definition}[Equivalence modulo V] Soit $V \subseteq \Vs$, \\
$c \sim^V_{res} c'$ ssi $\forall \sigma, \quad \semm{c}_{res} \sigma \sim^V \semm{c'}_{res} \sigma$, \quad
avec $\sigma_1 \sim^V \sigma_2$ ssi : 
$\left\{ \begin{array}{c}
\sigma_1 = \perp$ et $\sigma_2 = \perp\\
$ou$  \\
\forall x \in V, \sigma_1(x) = \sigma_2(x)\\
\end{array}\right.$
\end{definition}
\begin{itemize}
\item $\semm{skip}_{res} = id_{Etat}$
\item $\semm{ x := a }_{res} \sigma = \sigma [ x \leftarrow \semm{a} \sigma ]$
\item $\semm{c_1, c_2 }_{res} \sigma = \semm{c_2 }_{res} (\semm{c_1}_{res} \sigma)$ si on pose $\semm{c}_{res} \perp = \perp$ pour tout c
\item $\semm{c_1, c_2 }_{res} = \semm{c_2 }_{res} \circ \semm{c_1}_{res}$ : compostion de fonctions
\item $
\begin{array}{lll}
 \semm{\text{if b then }c_1\text{ else }c_2 } \sigma =&$si $\sigma \neq \perp :& \\
&&$si$ \semm{b} \sigma = tt$ alors $\semm{c_1}_{res} \sigma\\
&&$sinon  $\semm{c_2}_{res} \sigma\\
&$sinon $\perp\\
\end{array}$
\item $\begin{array}{lll}
\semm{\text{ while b do c} } \sigma=&$si $\sigma \not= \perp:\\
&&$si $\semm{b}\sigma = tt$ alors $(\semm{\text{while b do c} } \circ \semm{c}) \sigma,\\ 
&&$sinon $\sigma\\
& $sinon$\perp\\
\quad \hookrightarrow$ def récursive ???$
\end{array}$
\end{itemize}


Quelques équivalences:
\begin{itemize}
\item $c; skip \sim_{res}$ c $\sim_{res} skip; c$ " skip est neutre pour ;"
\item $c; loop \sim_{res}$ loop $\sim_{res} loop; c$ "loop est absorbant pour ;"
\item $(c_1; c_2); c_3 \sim_{res} c_1; (c_2;c_3)$  " ; est associatif"
\item  "; n'est pas commutatif"
\end{itemize}

\subsection{Sémantique naturelle (SN)}
 
 Sémantique à "grands pas".\\
 Relation de transition $\Rightarrow \subseteq (Prog \times Etat) \times Etat$\\

$\overline{ <skip, \sigma > \Rightarrow \sigma }$\\

$\overline{  <x:=a , \sigma > \Rightarrow \sigma [ x \leftarrow \semm{a } \sigma ] }$\\

$\dfrac{ <c_1, \sigma > \Rightarrow \sigma' \quad <c_2 , \sigma' > \Rightarrow \sigma'' }{<c_1, c_2, \sigma > \Rightarrow \sigma''}$\\


On construit un arbre au lieu de construire une suite.
\begin{definition}[Exécution]
Une exécution de c à partir de $\sigma$ est un arbre de dérivation dont la racine est de la forme $<c, \sigma > \Rightarrow \sigma'$.
\end{definition} 
\begin{rem}
avec cette définition, une exécution termine toujours. Par abus de language, on dira que l'exécution boucle si l'arbre n'existe pas.
\end{rem}
\begin{definition}[Equivalence]
 $c \sim_{SN} c'$ ssi pour tout $\sigma, \sigma', < c, \sigma > \Rightarrow \sigma$ ssi $<c', \sigma > \Rightarrow \sigma'$.
\end{definition} 


\paragraph*{Résultat:}
On pose $\semm{c}_{res}^{SN} = \left\{ \begin{array}{ll}
 \sigma' &\text{ si } <c, \sigma > \Rightarrow \sigma' \\
 \perp & \text{sinon} \\
\end{array} \right.$

\begin{thm} C'est bien une fonction (déterministe).
\end{thm}

\section{Equivalence}
\begin{thm} $ \semm{ \cdot }_{res}^{SOS} = \semm{ \cdot }_{res}^{SN}$
\end{thm}

\begin{lem}[1] 
$ \begin{array}{l l}
\\
\forall c, \forall \sigma, \forall \sigma', & \text{si on a }(<c, \sigma> \Rightarrow \sigma')\\
											& \text{alors } (<c, \sigma> \rightarrow^* \sigma')
\end{array}$
\end{lem}

\begin{dem}
 induction sur l'arbre de dérivation de $<c, \sigma> \Rightarrow \sigma'$
\end{dem}


\begin{lem}
$ \begin{array}{ll}
\\
\forall c, \forall \sigma, \forall \sigma', &\text{si on a }(<c, \sigma> \Rightarrow^* \sigma')\\
											& \text{alors } (<c, \sigma> \rightarrow \sigma')
\end{array}$
\end{lem}

\begin{dem}
 récurrence sur la suite de dérivation de $<c, \sigma> \Rightarrow^* \sigma'$
\end{dem}


\begin{rem}Attention à l'équivalence de la sémantique des expressions sous la forme \\$<a, \sigma> \rightarrow n$ (SOS) et $\semm{a} \sigma = n$ (SN)
\end{rem}

\section{Traces}
On a défini $\semm{c}^{SOS}$ comme une sémantique de résultat\\
$\longrightarrow$ garder l'ensemble des calculs?\\
En général, on se fixe un ensemble d'états initiaux $I \subseteq Etats$
\begin{itemize}
\item $\semm{c}_{tr} = $ ensemble des calculs maximaux en partant des états initiaux
\item on peut même définir l'ensemble des traces partielles : \\
tous les calculs à partir des états de I
\end{itemize}

Comment comparer des traces ? \begin{itemize}
\item les mêmes états intermédiaires : trop restrictif
\item la même longueur : pas assez
\end{itemize}
On sélectionne une partie de l'information des états intermédiaires et on la fait passer sur les transitions : transitions étiquetées.

étiquette vide : $\tau$

\begin{definition}[Traces étiquetées]
C'est une suite de configurations.\\
$\Pi = \gamma_0 \xrightarrow{l_0} \gamma_1 \xrightarrow{l_1} \cdots \xrightarrow{i-1} \gamma_i \xrightarrow{i} \cdots$
\begin{itemize}
\item $l_i \not = \tau $ : étiquette (label) visible (observable)
\item $l_i = \tau$ : transition non observable, muette
\end{itemize}
La suite des étiquettes de $\Pi$ (encore appelée trace) est $l_0l_1\cdots l_i$.
\end{definition}

\begin{definition}[Equivalence observable]
$c \equiv_{OB} c'$ si les suites des étiquettes visibles extraites des traces de $c$ et $c'$ sont identiques.
\end{definition}

\section{Exceptions}

\paragraph*{Sémantique : }
\begin{itemize}
\item lever : $\overline{<\text{throw }e; c,\sigma> \xrightarrow{e} <\sigma>}$\\

\item propager :$\dfrac{<c, \sigma > \xrightarrow{e} <\sigma>}{<c;c', \sigma > \xrightarrow{e} <\sigma>}$ \\

\item rattraper : \begin{itemize}
\item $\dfrac{< c, \sigma > \xrightarrow{\tau} < c', \sigma' >}{<\text{try }c\text{ catch }e;c'', \sigma > \xrightarrow{\tau} <\text{try }c'\text{ catch }e:c'', \sigma > }$\\
\item  $\dfrac{< c, \sigma > \xrightarrow{e} \sigma}{<\text{try }c\text{ catch }e;c', \sigma > \xrightarrow{\tau} <c', \sigma > }$ : l'exception est traitée par $c'$\\
\item  $\dfrac{< c, \sigma > \xrightarrow{l} \sigma}{<\text{try }c\text{ catch }e;c', \sigma > \xrightarrow{l} < \sigma > }, l \not = e$
\end{itemize}
\end{itemize}
\begin{rem} Les exceptions se propagent de  haut en bas mais pas de gauche à droite :  si toutes les exceptions sont rattrapées, aucune n'est observable pendant l'exécution.
\end{rem}

\begin{thm} Un calcul maximal de c à partir de $\sigma$ est de l'une des formes suivantes : 
\begin{enumerate}
\item $<c, \sigma> \xrightarrow{\tau}^* \sigma'$
\item $<c, \sigma> \xrightarrow{\tau}^{\infty}$
\item $<c, \sigma> \xrightarrow{\tau}^* <c',\sigma'> \xrightarrow{e}^* \sigma'$ avec $e \not = \tau$
\end{enumerate}
\begin{enumerate}
\item on pose $\semm{c}_{res} \sigma = \sigma'$
\item on pose $\semm{c}_{res} \sigma = \perp$
\item on pose $\semm{c}_{res} \sigma = \Delta$ état d'erreur
\end{enumerate}
\end{thm}

Pour retrouver la compositionnalité, on crée autant d'états d'erreur que d'exceptions.

\section{Sémantique opérationnelle pour un language non structuré}
Language non structuré : affectations, sauts conditionnels.

\subsection{Sémantique opérationnelle}
Etat = Label $\times$ Environnement\\

\begin{itemize}
\item $\dfrac{instr\_at(i) \equiv x:=a }{(i, \sigma) \rightarrow (next(i), \sigma[x \leftarrow \semm{a}])}$\\
\item $\dfrac{instr\_at(i) \equiv \text{goto j} }{(i, \sigma) \rightarrow (j \sigma)}$
\end{itemize}

\part{Sémantique dénotationnelle}
\paragraph{idée:} la sémantique d'un programme est une fonction (partielle) ``état initial $\mapsto$ état final''\\
On va définir proprement cette fonction.

On garde \sem{a} : Etat $\rightarrow \Zs$, \sem{b} : Etat $\rightarrow \{tt, ff \}$

\section{Définition de la sémantique dénotationnelle}
Notation :\begin{itemize}
           \item $x$ : variables
           \item $\lambda x . f : x$  argument de la fonction tel que f est le corps de la fonction
           \item $(f g)$ : application de la fonction f à l'argument g
          \end{itemize}

\begin{definition}[variables libres, liées]
 \begin{itemize}
  \item toutes les occurences de $x$ sont liées dans $\lambda x . f$
  \item les occurences non liées sont libres
  \item une variable est libre dans $f$ si elle a au moins une occurence libre dans $f$
 \end{itemize}
\end{definition}

\begin{definition}[renommage ou $\alpha$ conversion]
 $\lambda x . f →_{\alpha} \lambda y . f[y / x]$ : on substitue dans f toutes les occurences libres de y par x
\end{definition}
\begin{definition}[$\beta$ réduction]
 $(\lambda x . f ) t →_{\beta} f[t/x]$
\end{definition}
\begin{rem}
 Attention aux variables libres de $t$ : il ne faut pas qu'elles se fassent piéger par un $\lambda$ présent dans $f$: il faut faire un renommage avant d'appliquer la fonction.
Si $f→_{\beta} g$, on notera $f = g$
\end{rem}

\paragraph{Sémantique des expressions}
$\semm{a_1 + a_2} = \lambda \sigma.((\semm{a_1} \sigma) + (\semm{a_2}\sigma))$ par exemple
\paragraph{Sémantique des commandes}
\begin{itemize}
 \item $\semm{skip} = \lambda x . x$
 \item $\semm{x := a} = \lambda \sigma . \sigma[ x ← (\semm{a} \sigma)]$
 \item $\begin{array} {lll}\semm{\text{if $b$ then $c_1$ else $c_2$}}&
					  = \lambda \sigma . &$ si $(\semm{b} sigma) = tt$ alors $(\semm{c_1} \sigma)\\
                                                         &  &$ sinon $(\semm{c_2} sigma)\\
					 & = Cond( \semm{b} , \semm{c_1}, \semm{c_2})
                                         \end{array}$

\end{itemize}
\begin{rem}
\begin{itemize}
 \item on peut démontrer que l'on peut exprimer $Cond$ en notation $\lambda$
 \item on admet aussi que l'on peut exprimer en $\lambda$ calcul tous les calculs arithmétiques
\end{itemize}

\end{rem}

\begin{prop}
$ \semm{\text{while }b\text{ do }c} = \semm{\text{ if $b$ then $c$; while $b$ do $c$ else skip}}$
\end{prop}


\section{Points fixes}

\subsection{Ordres partiels complets}
On veut donner un ordre sur les fonctions $Etat \rightarrow Etat_{\perp}$ afin d'être capable de définir un plus petit point fixe.
\begin{definition}[Ordre partiel]
 Un ordre partiel $(E,\sqsubseteq)$ est un ensemble muni d'une relation réflexive, transitive, anti-symétrique.
\end{definition}
\begin{definition}[Borne Sup]
 Une borne supérieure de $X \subseteq E$ est un élément $m$ de $E$ tel que \\
\indent $\forall x \in X, \quad x \sqsubseteq m$.\\
$p$ est la plus petite borne supérieure de $X$ si $p$ est une borne sup de $X$ et $\forall \: p'$ borne sup de $X$, $p \sqsubseteq p'$.

Notation : $p = \sqcup X$
\end{definition}
\begin{definition}[Ordre partiel complet (CPO)]
 Un ordre partiel complet $(E,\sqsubseteq)$ est un ordre partiel tel que toute chaîne croissante $e_1 \sqsubseteq \dots \sqsubseteq e_n \sqsubseteq \dots $ a une borne supérieure $\sqcup \{ e_n \}$ dans $E$.

 Cas particulier : CPO avec plus petit élément : $\perp$.
\end{definition}
\begin{exs}[de CPO :]
 \begin{itemize}
  \item CPO plat : identité $\oplus \perp \sqsubseteq x \forall x$ 
  \\ $\hookrightarrow Etat_{\perp}$ est un CPO plat
  \item Si $E$ est un ensemble quelconque ($\mathcal{P}(E), \subseteq)$ est un CPO ($\perp = \varnothing $).
  \item produit de CPO : si $(A, \sqsubseteq_A)$ et $(B, \sqsubseteq_B)$ sont des CPO, alors $(A\times B, \sqsubseteq_{A\times B})$ est un CPO.
 \end{itemize}

\end{exs}

\subsection{Points fixes dans un CPO}

\paragraph{Rappel :} on cherche à définir une fonction $\Phi : Etat \to Etat_{\perp}$, point fixe d'une fonctionnelle $\mathcal{F}$.\\
On va avoir besoin de propriétés sur la fonction $\mathcal{F}$.

\begin{definition}[Monotonie] Une fonction $\mathcal{F} : D\to E$ où $D$ et $E$ sont des CPO est monotone ssi \\
\indent$\forall d, d' \in D, \quad d \sqsubseteq_D d' \; \Rightarrow \mathcal{F}(d) \; \sqsubseteq_E \mathcal{F}(d')$.
\end{definition}

\subparagraph{Intuition :} $\sqsubseteq$ va représenter un ``ordre d'information''.


$\Phi \sqsubseteq \Phi' : \Phi$ contient plus d'information que $\Phi'$.

\begin{definition}
 $\Phi \sqsubseteq \Phi'$ ssi $\forall \sigma, \; \Phi(\sigma) \sqsubseteq \Phi'(\sigma).$\\
On peut voir $\Phi$ comme un ensemble de couples $(\sigma, \sigma')$ avec $
\begin{array}{l}
  \sigma \in Etat\\
 \sigma' \in Etat \\
 \Phi(\sigma) = \sigma'\\
\end{array}\\
\begin{array}{l l l}
\Phi \sqsubseteq \Phi'$ ssi $\forall \sigma \in Etat,&$  si $\Phi(\sigma) = \sigma' \in Etat,&$ alors $\Phi'(\sigma) = \sigma'\\
&$ si $\Phi(\sigma) = \perp,&$ alors $\Phi'(\sigma) =$  n'importe quel élément de $Etat
\end{array}$
\end{definition}


La fonction qui contient le moins de couples: $\lambda \sigma . \perp =^{def} \perp$.\\
Monotonie de $\mathcal{F}$ : $\mathcal{F}$ préserve l'ordre d'information.\\
On va calculer $\Phi$ par approximations successives, en ajoutant au fur et à mesure des couples grâce à $\mathcal{F}$.\\
$\Phi = \bigsqcup (\text{borne sup})$ d'une chaîne croissante d'ensembles de couples.

\begin{definition}[Continuité] Une fonction $\mathcal{F} : D \to E$ monotone est continue ssi\\ pour toute chaîne croissante $d_0 \sqsubseteq_D d_1 \sqsubseteq_D d_2 \cdots  \sqsubseteq_D \sqsubseteq \cdots ,$\\
\indent$\displaystyle\bigsqcup_n \mathcal{F} (d_n) = \mathcal{F}( \bigsqcup_n d_n)$
\end{definition}

\begin{definition}[Point fixe]
 Soit $\mathcal{F} : D \to D$ une fonction continue sur une CPO $D$.\\
 Un point fixe de $\mathcal{F}$ est un élément $d$ de $D$ tel que $\mathcal{F}(d) = d$.
\end{definition}

\begin{thm}[Kleene]
 Soit $\mathcal{F}$ une fonction continue sur un CPO $D$ avec plus petit élément. \\
On pose  $\displaystyle\phi = \bigsqcup_n \mathcal{F}^n(\perp).$\\
$\phi$ est le plus petit point fixe de $\mathcal{F}$.
\end{thm}

\subsection{Sémantique de while}
\sem{\text{while b do c}} = fix $\displaystyle F = \bigsqcup_n F^n(\perp)$ avec $\perp = \lambda \sigma. \perp$\\
avec $F = \lambda \Phi . Cond( \semm{b}, \Phi \circ \semm{c}, id)$\\
$\Phi_0 = \perp \equiv \varnothing$\\
$\Phi_1 = F^1(\perp) = Cond( \semm{x \geq 0}, \perp \circ \semm{x :=x -1}, id) = \lambda \sigma. \text{si }\sigma(c) \geq 0\text{ alors } \perp \text{ sinon } \sigma.$\\
$\equiv \{ (\sigma, \sigma) / \sigma(x) < 0 \}$\\
représente : si $x < 0$ avant l'exécution, on n'entre pas dans la boucle (0 itérations) et on renvoie l'état de départ.\\
$
\begin{array}{l l l l}
\Phi_2 = F^2(\perp) & = F(\Phi_1)\\
		    & = Cond( \semm{x \geq 0}, \Phi_1 \circ \semm{x :=x -1}, id)\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\\
		    & = \lambda \sigma. &\text{ si }\sigma(x) \geq 0 \text{  alors }&\text{si } \sigma(x) -1 \geq 0 \text{  alors }\perp\\
										 & &&\text{sinon }\sigma[x \leftarrow \sigma(x) -1]\\
					&&\text{sinon }\sigma
\end{array}$\\
\indent$\equiv \{(\sigma, \sigma) / \sigma(x) < 0 \} \bigcup \{(\sigma, \sigma(x \leftarrow \sigma(x)-1 / 0 \leq \sigma(x) \leq 1 \}$\\
\\
D'où par récurrence : \\
$\Phi = \bigsqcup F^n(\perp) = \lambda \sigma . \left\{ \begin{array}{ll}
                                                      \sigma & $si $\sigma(x) < 0\\
						      \sigma[x \leftarrow -1] & $si $\sigma(x)>0
                                                     \end{array} \right.$

\begin{thm} Soient \sem{b} : Etat $\to \{ff, tt \}, \; \semm{c} : Etat \to Etat_{\perp}$\\
$\lambda \Phi . \: Cond( \semm{b}, \Phi \circ c, id)$ est une fonction continue de $(Etat \to Etat_{\perp}) \to (Etat \to Etat_{\perp})$.
\end{thm}

\section{Équivalence avec la sémantique opérationnelle}
\begin{thm} $\forall c \in Com, \; \forall \sigma, \sigma' \in Etat\\
\semm{c} \sigma = \sigma'$ ssi $<c, \sigma> \Rightarrow \sigma'$.\\
\end{thm}

\begin{dem}[Winskel] \fbox{$\Leftarrow$} On définit $R(c, \sigma, \sigma')$ ssi $\semm{c} \sigma = \sigma'$
SN $(\Rightarrow)$ est la plus petite relation sur $Com \times Etat \times Etat$ qui vérifie les règles d'inférence de SN.
Il suffit de vérifiier que R vérifie toutes les règles de SN.
On a alors $\Rightarrow \subseteq R$, ce qui nous donne $(<c, \sigma> \Rightarrow \sigma') \Longrightarrow (\semm{c} \sigma = \sigma')$


\fbox{$\Rightarrow$} Par récurrence sur le nombre d'itérations qui ont servi à construire un couple $(\sigma, \sigma')$ dans la sémantique dénotationnelle.
\end{dem}


\section{Sémantique dénotationnelle par continuation}

La sémantique dénotationnelle vue jusqu'à présent est dite directe : $ \sigma \stackrel{\semm{c}}{\rightsquigarrow} \sigma'$\\
$c_1;c_2$ :\og  exécuter $c_1$ puis $c_2$ \fg (composition de fonctions) : on ne peut pas changer le flôt de contrôle.\\
$\hookrightarrow $ pb avec les exceptions.\\
Lever une exception = changer de futur.\\
Futur = continuation.

$\left.\begin{array}{r l l}
  \sigma & \\
 \left.\fbox{
 \begin{minipage}{3cm}
 \centering x:= 1
 \end{minipage}} \hspace{0.2cm}\right\downarrow& \\
 \sigma' & \\
\left.\fbox{
 \begin{minipage}{3cm}
\vspace{0.5cm}
\centering futur
\vspace{0.5cm} \quad
 \end{minipage}}\hspace{0.2cm}\right\downarrow &   c& \\
 \sigma'' & \\
\end{array}\right\downarrow c'$\qquad \qquad \qquad  \textcolor{red}{\fbox{\color{black}programme = transformateur de futur}}

On reprend les domaines sémantiques : 
\begin{itemize}
 \item $\sigma \in Etat = \Vs \to \Ns$
 \item $c \in Cont = Etat \to Etat_{\perp}$
 \item $\mathcal{C} \semm{P} \in Cont \to Cont$
\end{itemize}

\subsection{Sémantique de WHILE}

\begin{itemize}
 \item skip : $\mathcal{C}\semm{skip} c = c$ : $\mathcal{C}\semm{skip} = id_{cont}$\\
 \item sequence : $c'' = \mathcal{C}\semm{P} c' = \mathcal{C}\semm{P}(\mathcal{C}\semm{Q} c)$\\
		  $\mathcal{C}\semm{P, Q} = \mathcal{C}\semm{P} \circ \mathcal{C}\semm{Q}$\\
 \item affectations :  $\mathcal{C}\semm{x:=a} c = c'$ avec $c' \sigma = \sigma'' = c \sigma' = c \sigma[x \leftarrow \semm{a} \sigma])$\\
 \item choix : 
$\begin{array}{ll}
\mathcal{C}\semm{\text{if $v$ then $P$ else $Q$}} c = c'\text{ avec }c' \sigma =&\text{si }\semm{b} \sigma = tt \text{ alors } (\mathcal{C}\semm{P} c) \sigma \\
 &\text{sinon } (\mathcal{C}\semm{Q} c) \sigma\\
   \mathcal{C}\semm{\text{if v then P else Q}} = \lambda c. \lambda \sigma. &\text{si } \semm{b} \sigma = tt\text{ alors } \mathcal{C}\semm{P} c \sigma  \\
 &\text{sinon } \mathcal{C}\semm{Q} c \sigma\\
\end{array}$
 \item boucle : \\$
\begin{array}{ll}
 \mathcal{C}\semm{w} c \sigma = &\text{si } \semm{b} \sigma = tt \text{ alors } (\mathcal{C}\semm{P} \mathcal{C}\semm{w}) c \sigma \\
  &\text{sinon } c \sigma\\
\end{array}\\
\begin{array}{ll}
 \mathcal{C}\semm{w} = Fix F \text{ où } F = \lambda \Phi .  \lambda c. \lambda \sigma. &\text{si } \semm{b} \sigma = tt \text{ alors } (\mathcal{C}\semm{P} \circ \Phi) c \sigma \\
&\text{sinon } c \sigma\\ 
\end{array}\\
F = \lambda \Phi \lambda c . Cond ( \semm{b},  (\mathcal{C}\semm{P} \circ \Phi) c, c)\\
$
\end{itemize}
CPO utilisé : $[C_{cont} \to C_{cont}]$ fonctions continues


\subsection{Continuation d'expressions}
On regarde ce qui se passe avec $x:=a$:
\begin{itemize}
 \item Calcul de la valeur de $a$
 \item affectation proprement dite
 \item $k$ : continuation d'expression \begin{tabular}{l}
                                        arguments : une valeur et un état \\
					$ECont : \Zs \rightarrow Etat \rightarrow Etat_{\perp}$\\
					$\mathcal{C}\semm{x:=a} = \mathcal{E}\semm{a} k$\\
					avec $k = \lambda v. \lambda \sigma' . (c \sigma'[x\leftarrow v])$
                                       \end{tabular}

\end{itemize}


\begin{definition}[$\mathcal{E}\semm{a}$]
~~\\

$ \left.\begin{array}{r l}
     \sigma \\
 \left. \fbox{
 \begin{minipage}{2cm}
 \centering $n$
 \end{minipage}} \hspace{0.2cm} \right\downarrow  & \\
    n, \sigma\\
 \left.\fbox{ \begin{minipage}{2cm}
 \vspace{2cm} \quad
 \end{minipage}} \hspace{0.2cm} \right\downarrow& k \\
  \sigma''
\end{array}\right\downarrow c$\qquad
\begin{minipage}{200pt}
$\E\semm{n} k \, \sigma =  c \sigma = k n \sigma$\\
$\Leftrightarrow \E\semm{n} k = \lambda \sigma. k \sigma$
\end{minipage}
$ \left.\begin{array}{r l}
     \sigma \\
 \left. \fbox{
 \begin{minipage}{2cm}
 \centering $x$
 \end{minipage}} \hspace{0.2cm} \right\downarrow  & \\
    \sigma(x), \sigma\\
 \left.\fbox{ \begin{minipage}{2cm}
 \vspace{2cm} \quad
 \end{minipage}} \hspace{0.2cm} \right\downarrow& k \\
  \sigma''
\end{array}\right\downarrow c$\qquad
\begin{minipage}{200pt}
$\E\semm{x} k \, \sigma = \sigma'' = c \sigma = k \,\sigma(x)\, \sigma$\\
$\E\semm{x} = \lambda k. \lambda \sigma .(k \, \sigma(x) \, \sigma)$\\
\end{minipage}

$ \left.\begin{array}{r l}
     \sigma \\
  \fbox{
 \begin{minipage}{2cm}
 \centering $a_1$
 \end{minipage}} \hspace{0.2cm}  \\
    v_1, \sigma\\
      \left.\begin{array}{r l}
       \fbox{ \begin{minipage}{2cm}
	\centering$a_2$
	 \end{minipage}} \hspace{0.2cm}  \\
	 v_2, \sigma\\
		\left.\begin{array}{r l}
		\fbox{ \begin{minipage}{2cm}
		\centering$+$
		\end{minipage}} \hspace{0.2cm}  \\
		v_1 + v_2, \sigma\\
 \left.\fbox{ \begin{minipage}{2cm}
 \vspace{2cm} \quad
 \end{minipage}} \hspace{0.2cm} \right\downarrow& k \\
  \sigma''
\end{array}\right\downarrow k'\end{array}\right\downarrow k''\end{array}\right\downarrow c$\qquad
\begin{minipage}{200pt}
$\E\semm{a_1 + a_2} k \, \sigma = \E\semm{a_1} k'' \sigma$\\
avec $\begin{array}{l}
      k'' \; v_1 \; \sigma_1 = \E \semm{a_2} k' \;\sigma_1\\
      k' \;v_2\; \sigma_2 = k \;(v_1 + v_2) \;\sigma_2
     \end{array}$\\
d'où $\E\semm{a_1 + a_2} = \\ \lambda k . ( \E\semm{a_1} \; \lambda v_1 . (\E\semm{a_2} \; \lambda v_2. ( k \; v_1 + v_2)))$
\end{minipage}

\end{definition}

\begin{ex}[Effet de bord :]
 
$\left.\begin{array}{c l l}
 & \sigma & \\
 \fbox{
 \begin{minipage}{3cm}
 \centering x++
 \end{minipage}} & \\
& \sigma(x), \sigma[x \leftarrow \sigma(x)+1] & \\
\left.\fbox{
 \begin{minipage}{3cm}
\vspace{3cm} \quad
 \end{minipage}}\right\downarrow &   k& \\
& \sigma'' & \\
\end{array}\right\downarrow$ c

$\E\semm{x++} = \lambda k. \lambda \sigma . (k \sigma(x) \sigma[x \leftarrow \sigma(x) +1])$

affectation avec effet de bord :\\
$\mathcal{C}\semm{x:=a} c \sigma = \E\semm{c} k \sigma$ avec $k \, v\,  \sigma' = c \, \sigma'[x \leftarrow v]$ 
\end{ex}

Tests : on définit $\E \semm{b}$ de la même façon que  $\E \semm{a}$

\subsection{Exceptions}

$\mathcal{C} \semm{\text{throw }e}\, c \,\sigma = c_e \,\sigma$ \qquad $e \mapsto c_e$ : on stocke cette information \begin{tabular}{l}
                                                                                                     soit dans $\sigma$\\
                                                                                                     soit dans un nouvel environnement
                                                                                                    \end{tabular}\\
Environnement d'exception : $E \in Exn → Ccont$\\
$\mathcal{C}  \semm{\text{throw }e}\, E \,c \,\sigma = E(e) \, \sigma$\\
$\mathcal{C}  \semm{\text{try $P$ catch $e;Q$}} = \mathcal{C}\semm{P} \,E[e ← \mathcal{C}\semm{Q}\, E \,c] \,e \,\sigma$

Il faut réécrire la sémantique $\mathcal{C}  \semm{ .}$ pour tenir compte de $E$:\\
$\mathcal{C}  \semm{P_1;P_2} E = (\mathcal{C}  \semm{P_1}E \circ \mathcal{C}  \semm{P_2}E)$ → assure que s'il y a 
un $try$ dans $P_1$ on retrouve bien $E$ dans $P_2$.
\subsection{Portée des variables}
Ajouter des variables locales : notion de bloc \\
$P ::=$ $begin$ $var$ $x; P$ $end$


$\left.\begin{array}{c r c c}
 \text{var }x \\
& \fbox{
 \begin{minipage}{3cm}\centering
 \vspace{0.3cm}P \vspace{0.3cm}
 \end{minipage}}\\
\text{restorer }x  &\sigma' & \\
&  \left.\fbox{
\begin{minipage}{3cm}
\vspace{2cm} \quad
 \end{minipage}} \right\downarrow  &  c \\
\end{array}\right\downarrow c$

$\mathcal{C}\semm{\text{begin var $x$; $P$ end}} c \sigma =  \mathcal{C}\semm{P} c' \sigma[x \leftarrow default]$ avec $c' \sigma'  = c \sigma'[x \leftarrow \sigma(x)]$



\subsection{Notion de réponse}
Pour l'instant :  $\begin{array}{ccc}
                   Ccont &=& Etat \rightarrow Etat_{\perp}\\
		    $résultat$ &=&$état final$\\
		    \downarrow \\
		     $réponse$\\
                  \end{array}$

Cas généralisé : $Ccont : Etat \rightarrow R\acute{e}ponse$

\begin{ex}[1] état final, Réponse = $Etat_{\perp} \quad \mathcal{C}\semm{P} Id$ avec $Id = \lambda \sigma . \sigma$
\end{ex}
\begin{ex}[2]  Réponse = $\Zs \quad \mathcal{C}\semm{P} ( \lambda \sigma . \sigma(x)$
\end{ex}
\begin{ex}[3]  Réponse = \{ok, erreur\} $\E\semm{\text{sqrt a}} = \E\semm{a} k' \sigma$ \\
\begin{tabular}{ll}
 avec $k' v \sigma' = $ & si $v \geq 0$ alors $ k \sqrt{v} \sigma'$\\
  & sinon erreur.\\
\end{tabular}
On calcule $\mathcal{C}\semm{P} c_p$ avec $c_p = \lambda \sigma . OK$
\end{ex}
\begin{ex}[4 : affichage] On ajoute P ::= print a.\\
Réponse : ensemble des suites d'entiers : $\Zs^*$.

$\mathcal{C}\semm{print a} c \sigma = \E\semm{a} k \sigma$ avec $k v \sigma' = v::(c \sigma')$.
On calcule ${C}\semm{P} (\lambda \sigma [])$

 Réponse = $Etat_{\perp} \quad \mathcal{C}\semm{P} Id$ avec $Id = \lambda \sigma . \sigma$.
\end{ex}



\part{Sémantique axiomatique}

Décrire et prouver des propriétés de programme.

\begin{ex}
 $P \equiv y=1;$while $\lnot (x=1)$ do $(y:=y \times x; x := x-1)$\\
\begin{minipage}[c]{150pt}
 \begin{propriete}\og si $x \geq 1$, $P$ calcule la factorielle de $x$ dans la variable $y$ \fg\end{propriete}
\end{minipage}\begin{minipage}[c]{150pt}
\begin{dem}
 rec sur la longueur $n$ de $<P, \sigma> →^n \sigma'$
\end{dem}\end{minipage}\hspace{1cm}\begin{minipage}[b]{100pt}
                        $\longrightarrow$ pénible
                       \end{minipage}


\begin{itemize}
 \item avec $SOS$ (directe, sans continuation) : $\forall \sigma, \sigma',$ si $<P, \sigma> →^*$ alors $\sigma'(y) = \sigma(x)$!\\
problème : n'assure pas que $\sigma(x) \geq 1$
\item avec $SD$ (directe, sans continuation) : $\Ps(Phi) = \forall \sigma, \sigma',$ si $\Phi \sigma = \sigma'$ alors $\sigma'(y) = \sigma(x)$ !\\
On veut montrer $\Ps(\semm{P})$ → il faut montrer que $\Ps$ passe à la borne sup + induction de point fixe → compliqué.
\end{itemize}
\end{ex}


$\Rightarrow$ On va dissocier la partie programme de la partie logique.

\section{Language d'assertions}
On va écrire les triplets de Hoare : $\{A\}P\{B\}$ \begin{tabular}{l}
                                                    A : précondition\\B : postcondition
                                                   \end{tabular}

\og Si A est vraie avant l'exécution de P, alors B est vraie après \fg 

\quad→ ils sont écrits dans le language d'assertions.

\subsection{Syntaxe}
\begin{itemize}
 \item expressions : on garde les mêmes que pour WHILE, mais sur un ensemble de variables plus grand : $\Vs \cup \Vs_L $(variables logiques) $(\Vs \cap \Vs_L = \varnothing)$\\
On continue à noter les expressions arithmétiques.
\item assertions : $Assn \ni A ::= true | false | a_1 = a_2 | a_1 < a_2 | \dots | A_1 \vee A_2 | \lnot A | \forall u A | \exists u A$
\end{itemize}
\begin{rem}
 Il existe une traduction directe de $Bexp$ vers $Assn : \lceil b_1$ and $b_2 \rceil =  \lceil b_1 \rceil \wedge \lceil b_2 \rceil$ \\
→ On notera b pour une assertion issue d'une expression booléenne.
\end{rem}
Notation de substitution dans les assertions :
\begin{itemize}
 \item $A[a/x]\; (x \in \Vs)$ : remplacer dans $A$ toutes les occurences de $x$ par $a$\\
 ($x$ ne peut être liée car les quantificateurs ne portent que sur $\Vs_L$).
 \item $A[a/x] \;(x \in \Vs_L)$ : remplacer dans $A$ toutes les occurences libres de $x$ par $a$.
\end{itemize}


\subsection{Sémantique des assertions}
Les états sont étendus avec les variables logiques :
$\sigma \in Etat (\Vs \cup \Vs_L) → \Zs$\\

On définit la sémantique des expressions \sem{a} comme d'hab.\\
Notation pour la validité d'une assertion $\sigma \models A$ : \og A est vraie dans $\sigma$ \fg.\\
→ Validité définie par induction sur la syntaxe de A

$\forall \sigma \in Etat$:
\begin{itemize}
 \item $\sigma \models true$
\item $\sigma \not \models false$
\item $\sigma \models (a_1 = a_2)$ ssi $\semm{a_1} \sigma  = \semm{a_2} \sigma  $
\item $\sigma \models (A \vee B )$ ssi $\sigma \models A$ ou $\sigma  \models B$
\item $\sigma \models \exists u A$ ssi $\exists n \in \Zs \tq \sigma[u←n] \models A$
\item $\sigma \models \forall u A$ ssi $\forall n \in \Zs, \sigma[u←n] \models A$
\end{itemize}
\begin{prop}
 pour tout $b \in Bexp, \semm{b} \sigma = tt$ ssi $\sigma \models \lceil b \rceil$
\end{prop}
\begin{definition}[tautologie]
$\models A$ ssi $\forall \sigma, \sigma \models A $
\end{definition}

\section{Triplets de Hoare}
Donner une sémantique à $\{A\}P\{B\}$

\begin{definition}
 $\sigma \models \{A\}P\{B\}$ ssi $(\sigma \models A$ et $\semm{P} \sigma = \sigma')$ implique $\sigma' = B$\\
(on utilise la sémantique dénotationnelle mais on pourrait aussi utiliser SOS)
\end{definition}

\paragraph{Validité d'un triplet :} (correction partielle)
\begin{definition}
 $\models \{A\}P\{B\}$ ssi $\forall \sigma, \sigma \models \{A\}P\{B\}$
\end{definition}
\begin{rem}
 Si on adopte la convention $\bot \models A$ pour tout $A$, on peut définir $\sigma \models \{A\}P\{B\}$ par :\\
si $\sigma \models A$ alors $\semm{P} \sigma \models B$
\end{rem}

\begin{exs}
 \begin{itemize}
  \item Soient $u \in \Vs_L, x \in \Vs,$ et  $P \equiv x := x+1$\\
 $\models \{ u < x \} P \{ u < x\}$ ?\\
\begin{minipage}{400pt}\begin{dem}
 Soit $\sigma \tq \sigma \models u<x$. On a donc $\sigma(u) < \sigma(x)$, \\or $\semm{x := x+1} \sigma = \sigma [x ← \sigma(x) +1] = \sigma'$\\
$\begin{array}{llc}
 \sigma' \models u< x&$ssi $\sigma'(u) < \sigma'(x)\\
		    &$ssi $\sigma'(u)<\sigma(x)+1$ ssi $vrai&\quad \Rightarrow$ le triplet est valide$
\end{array}$

\end{dem}\end{minipage}
\item $\models \{true\} P \{true\}$
\item $\models \{false\} P \{false\}$
\item $\models \{false\} P \{true\}$
\item $\not \models \{true\} P \{false\}$
\item $\models \{true\} loop \{false\}$ (car ne s'arrête pas)
 \end{itemize}

\end{exs}

\begin{prop}
 P diverge à partir de $\{ \sigma  \tq \sigma \models A \}$ ssi $\models \{A\}P\{false\}$
\end{prop}

Notion de correction totale ( Attention notations diverses)

$\sigma \models [A]P[B]$ ssi $\sigma \models A$ implique $( \exists \sigma' \in Etat, \semm{P} \sigma = \sigma' et \sigma' \models B)$

\begin{thm}
 Il n'existe pas d'algo pour décider la validité de $\{A\}P\{B\}$ (que ce soit en correction partielle ou totale)
\end{thm}

Comment savoir si un triplet est valide?\\
→ on va construire une preuve $\vdash \{A\}P\{B\}$ telle que $\vdash \{A\}P\{B\}$ implique $\models \{A\}P\{B\}$\\
→ système de déduction

\section{Logique de Hoare}
\subsection{Règles de preuve pour la correction totale}
Induction sur la structure de P
\begin{itemize}
 \item $\dfrac{}{\{A\}skip\{A\}}$\\
 \item $\dfrac{\{A\}P\{B\} \quad \{B\}Q\{C\}}{\{A\}P;Q\{C\}}$\\
 \item $\dfrac{\{A \wedge b\}P\{B\} \quad \{A \wedge \lnot b\}Q\{B\}}{\{A\}\text{ if $b$ then $P$ else $Q$ }\{B\}}$\\
 \item non pas $ \dfrac{}{\{A\}x := a\{A[x/a]\}}\text{ mais }\dfrac{}{\{B[a/x]\}x := a\{B\}}$ axiome\\
 \item $\dfrac{\models A \Rightarrow A' \quad \{A'\}P\{B\} \quad \models B \Rightarrow B'}{\{A\}P\{B\}}$ : affaiblissement\\
 \item $\dfrac{\{I \wedge b \}P\{I\}}{\{I\}\text{while $b$ do }P\{I \wedge \lnot b\}} I$ : invariant de boucle\\
\end{itemize}

\subsection{Correction totale}
correction partielle + terminaison (à prouver)

notation $\models_{tot} \{A\}P\{B\}$

$\dfrac{ \{I \wedge b \wedge u = t\}P\{I \wedge t<u\}}{\{I\}\text{while $b$ do $P$}\{I \wedge \lnot b\}}$ avec 
$\left\{\begin{array}{lcl}
 u & \in&  \Vs_L\\
t & = & \text{expression (variant de boucle)}\\
< & =& \text{ordre bien fondé : relation d'ordre sans chaîne infinie décroissante}
\end{array}\right.$

\subsection{Arbre de preuve}

Arbre de preuve : \begin{itemize}
                   \item les feuilles : axiomes.
                   \item chaque noeud est la conclusion d'une règle de preuve, ses fils étant les prémisses de cette même règle.
                   \item la racine est le théorème.
                  \end{itemize}

$\vdash \semh{A}{P}{B}$ : il existe un arbre de preuve de racine $\semh{A}{P}{B}$

\begin{ex}
$ p \equiv y := 1;$ while $x > 0$ do $(y := y \times x; x := x-1)$

\begin{description}
 \item [postcondition] $B \equiv y = n!$  \quad  (← on a ajouté la fonction $(!)$ au language d'assertions)
 \item[précondition] $A \equiv x \geq 0 \wedge n = x$
 \item[invariant] $I \equiv 0 \leq x \leq n \wedge y = \frac{n!}{x!}$
\end{description}
\end{ex}


\section{Lien entre preuve et validité sémantique}

$\begin{array}{lcrr}
\vdash \semh{A}{P}{B} & \xrightarrow{\text{correction}}& \models \semh{A}{P}{B} &  ← \text{indispensable, facile à prouver}\\
                       & \xleftarrow{\text{complétude}} & & ← \text{plus difficile à prouver sous certaines hypothèses}
\end{array}$

\begin{thm}
 Si $\vdash \semh{A}{P}{B}$ alors $\models \semh{A}{P}{B}$
\end{thm}
\begin{dem}
 vérifier que la relation $val(A,P,B) =^{def} \models \semh{A}{P}{B}$ est un modèle pour toutes les règles de preuve de la logique de Hoare.
\end{dem}

$\dfrac{}{\semh{A}{skip}{A}}$ : vérifier \og si \og rien \fg alors $val(A, skip, A)$
			      pour tout $\sigma \in Etat$, si $\sigma \models A$ alors $\semm{skip} \sigma \models A$

$\dfrac{}{\semh{B[a/x]}{x := a}{B}}$ vérifier : pour tout $\sigma \in Etat$, si $\sigma \models  B[a/x]$ alors $\sigma[x ← \semm{a} \sigma] \models B$

\begin{lem}[fondamental]
 $\forall a \in Aexp, \forall x \in V , \forall B \in Assn, \forall \sigma \in Etat,$

$\sigma \models  B[a/x] \Leftrightarrow \sigma[x ← \semm{a} \sigma] \models B$
\end{lem}

séquence : on suppose $\models \semh{A}{P}{C}^{(1)}$ et $\models \semh{C}{Q}{B}^{(2)}$; on vérifie $\models \semh{A}{P;Q}{B}$
	soit $\sigma \tq \sigma \models A et \semm{P;Q} \sigma \not = \bot$
	on a $\semm{P} \sigma = \sigma' \not = \bot ,$ et $\sigma' \models C$ (par (1))
	    $ \semm{Q} \sigma' = \sigma'' \not = \bot ,$ et $\sigma'' \models B$ (par (2))
	     or $\semm{P;Q} \sigma = \sigma''$

conditionnelle : à compléter

boucle : on suppose $\models \semh{I \wedge B}{P}{I}$
	 on vérifie$ \models \semh{I}{while b do P}{I \wedge \lnot B}$
	$ W = \semm{while b do P} = \sqcup_n F^n( \bot)$
	 on montre par récurrence sur n que 
	     $ \sigma \models I et (F^n( \bot))(\sigma) = \sigma' et \sigma' \not = \perp alors \sigma' \models I \wedge \lnot B$
\begin{dem}
 cf Winskel
\end{dem}

affaiblissement : facile

Th inverse ? difficultés : \begin{tabular}{l}
                            trouver les invariants\\
                           trouver les tautologies dans les affaiblissements
                           \end{tabular}

\section{Preuves par annotations}

notation à la Floyd

\begin{ex}
$ \{x \geq 0 \wedge n := x \}
 y := 1
 \{ x \geq 0 \wedge n = x \wedge y = 1\}
 while x > 0 do \{inv : 0 \leq x \leq n \wedge y = \frac{n!}{x!}\}
      \{ 0 \leq x \leq n \wedge y = \frac{n!}{x!}\}
      y:= y \times x
      \{0 \leq x \leq n \wedge y = \frac{n!}{(x-1)!}\}
      x :=x-1 
 \{y = n!\}$
\end{ex}


Notion de programme annoté : $P^*$
formation de triplets $\semh{A}{P^*}{B}$
\begin{ex}
 $\frac{\semh{A}{P^*}{C} \quad \semh{C}{Q^*}{B}}{\semh{A}{P^*;\{C\} Q^*}{B}}$ ← texte linéaire
\end{ex}
Les invariants sont des assertions spéciales$ \{inv: \dots \}$
A partir d'un programme annoté $P^*$, on peut retirer toute assertion non étiquetée par inv

\begin{thm}
 Il existe une preuve par annotations $\semh{A}{P^*}{B} ssi \models \semh{A}{P}{B}$
\end{thm}


\section{Plus faibles préconditions[Dijkstra]}

Preuve à la Hoare : en arrière
		    substitution (syntaxe)
	→ mécanisation 

$\semh{A}{P;Q}{B}$ il faut trouver C : en remontant à partir de B

? $\models \semh{A}{x:=a}{B}$ ça revient à prouver $\models A \Rightarrow B[a/x]$
					      si $\sigma \models A$ alors $\sigma \models B[a/x]$
					     $ \{\sigma \tq \sigma \models A \} \subseteq \{\sigma \tq \sigma \models B[a /x]\}$
→ le plus grand ensemble d'états possibles = la plus faible précondition

On va identifier assertions et ensembles d'état
		 $   A          \semm{A} = \{\sigma \in Etat_\bot \tq \sigma \models A \}$
				    avec la convention $\bot \in A \forall A$

\begin{definition}
 soit $P$ un programme, $B$ une assertion
 $WP(P,B) = \{ \sigma \in Etat_bot \tq \semm{P} \sigma \models B \}$
\end{definition}

\begin{prop}
 $\models \semh{A}{P}{B} ssi \semm{A} \subseteq WP(P,B)$ (on note aussi WLP, weakst libéral precondition)
\end{prop}

\begin{cor}
 Si il existe $A_0 \tq WP(P,B) = \semm{A_0}, alors \models \semh{A}{P}{B} ssi \models A \Rightarrow A_0$
\end{cor}

Question : un tel $A_0$ existe-t-il toujours ? → définissabilité

$WP(skip,B) = \semm{B}
WP(x:=a,B) = \{ \sigma \in Etat_{\bot} \tq \semm{x := a} \sigma \models B\}
	   = \{ \sigma \in Etat \tq \semm{x := a} \sigma \models B\} \cup \{bot\} = \semm{B[a/x]}
WP(P;Q,B) = WP(P, WP(Q,B))$ → ça marche si $WP(Q,B)$ est une assertion
$WP($if $b$ then $P$ else $Q, B) = (WP(P,B) \cap \{\sigma \in Etat, \semm b \sigma = tt \})
			\cup (WP(Q,B) \cap \{\sigma \in Etat, \semm b \sigma = ff \})
			\cup \{bot\}
$Si on suppose $WP(P,B) = semm{A_1} et WP(Q,B) = \semm{A_2} alors WP(if \dots) = \semm{ ( A_1 \wedge b) \vee (A_2 \wedge \lnot b)}$

$WP(while b do P; Q) = (WP(P, WP(while \dots , B)) \cap \{\sigma \in Etat \tq \semm{b} = tt \})
		      \cup (\semm{B} \cap \{\sigma \in Etat \tq \semm b \sigma ) ff \}
		      \cup {\bot}$

Il faut exprimer les itérations : 
$\sigma \in WP(while \dots, B) ssi \forall k \in \Ns , \forall \sigma_0, \dots, \sigma_k \in Etat, 
				    (\sigma = \sigma_0) \wedge \forall i ( 0 \leq i < k) \Rightarrow (\semm{b} \sigma_i = tt \wedge \semm{P} \sigma_i = \sigma i+1
				    \Rightarrow \sigma_k \models b \vee B$

formule avec états et $\semm{.} \rightsquigarrow$ assertion ?

miracle ! c'est définissable : Gödel : on code tout avec des entiers.

\begin{thm}
 pour tout programme P et toute assertion B, il existe une assertion $W(P,B) \tq \semm{W(P,B)} = WP(P,B)$
\end{thm}

\section{Complétude}
On veut prouver $\models \semh{A}{P}{B}$ implique $\vdash \semh{A}{P}{B}$

\begin{lem}
 Pour tous $P$ et $B$, $\vdash \semh{W(P,b)}{P}{B}$
\end{lem}
\begin{dem}[par induction sur la syntaxe de P :]
$P \equiv skip$ : on va montrer $\vdash \semh{W(skip,B)}{skip}{B}$
	on a $\vdash \semh{B}{skip}{B}$
    on utilise l'affaiblissement, avec $\models W(skip,B) \Leftrightarrow B$

$P \equiv P_1; P_2
	\sigma \models W(P_1;P_2,B) ssi \sigma \models W(P_1,W(P_2,B))
      donc \sigma \models W(P_1;P_2,B) \Leftrightarrow \sigma \models W(P_1,W(P_2,B))$
Par hypothèse d'induction, $\vdash \semh{W(P_1,B)}{P_2}{B}
			   \vdash \semh{W(P_1,W(P_2,B)}{P_1}{W(P_2,B)}
	  $donc $\vdash \semh{W(P_1,W(P_2,B)}{P_1;P_2}{B}
	 $ donc(affaiblissement) $\vdash \semh{W(P_1;P_2,B)}{P_1;P_2}{B}$


$P \equiv while b do P_1
      soit I = W(P,B)
       $il faut vérifier $(1) \models \semh{I wedge b}{P_1}{I}
			(2) \models I \wedge \lnot b \Rightarrow B
	$par hypothèse d'induction, $\vdash \semh{I \wedge b}{P_1}{I}
		      $donc (affaibl) $\models \semh{I}{P}{B}
$

\end{dem}
\begin{thm}[de complétude]
 Si $\models \semh{A}{P}{B}$ alors $\vdash \semh{A}{P}{B}$
\end{thm}
\begin{rem}
 On ne s'intéresse pas à la façon dont sont prouvées les tautologie.
\end{rem}
\begin{thm}[d'incomplétude de Gödel]
 Il n'existe pas d'algo pour construire une preuve de toute les tautologies en Assn.
\end{thm}

→ On parle de complétude relative (complétude au sens de Cook)


\part{Sémantique des languages fonctionnels}

\section{Syntaxe d'un language fonctionnel simple}

Language REC :
\begin{itemize}
 \item variables $\Vs$
 \item symboles des fonctions $f_1$, \dots, $f_n$ in $\Fs$
 \item chaque symbole de fonction $f_i$ est muni d'une arité $a_i$
 \item termes : $t$ ::= $n$ | $x$ | $t_1 + t_2$ | $t_1 * t_2$ | $t_1 - t_2$ | if $t_0$ then $t_1$ else $t_2$ | $f_i(t_1,\ \dots,\ t_{a_i}$)
\end{itemize}
Les booléens sont codés par des termes :  \begin{eqnarray}{rcl}
                                           0 & \to & vrai\\
					   n \neq 0 & \to & faux
                                          \end{eqnarray}
Les fonctions sont définies par des déclarations 
\begin{eqnarray}{rcl}
 f_1(x_1,\ \dots,\ x_{a_1}) & = & d_1\\
 f_k(x_1,\ \dots,\ x_{a_k}) & = & d_k
\end{eqnarray}


Les $d_i$ sont des termes; les variables de $d_i$ sont dans $\{ x_1 \dots x_n \}$
$d_i$ peut contenir un appel à $f_i$.

\section{Sémantique opérationnelle}

\begin{ex}
\begin{eqnarray}{rcl}
  f_1(x) & = & f_1(x) +1\\
  f_2(x) & = & 1
\end{eqnarray}

On veut évaluer $f_2(f_1(x))$ → résultat ?\\
Dépend de l'ordre d'évaluation : \begin{itemize}
                                  \item $f_1$ d'abord : appel par valeur
                                  \item $f_2$ d'abord : appel par nom
                                 \end{itemize}
\end{ex}

\subsection{Appel par valeur}
programme : terme clos (sans variable). On se fixe une déclaration d
règles $t \xrightarrow[va]{d} n$ : \og le terme clos t s'évalue en la valeur n par rapport à la déclaration d avec une stratégie d'appel par valeur \fg

\subsection{Appel par nom}

Règles $t \xrightarrow[no]{d} n$

\begin{rem}
 $\xrightarrow[no]{}$ et $\xrightarrow[va]{}$ sont à grand pas.
\end{rem}

\begin{prop}
 $\xrightarrow[no]{}$ et $\xrightarrow[va]{}$  sont compositionnelles et déterministes.
\end{prop}


\section{Sémantique dénotationnelle}

On procède en deux temps :
\begin{itemize}
 \item évaluation des termes dans un environnement qui contient la définition des fonctions
 \item définition d'un environnement associé à une déclaration
\end{itemize}

\subsection{Appel par valeurs}

Domaine sémantique : $p \in Env$ : $\Vs → \Zs$
Chaque fonction $f_i$ est associée à une fonction $\Phi_i$ : $\Zs^{a_i} → \Zs_{\bot}$
$F\,Env_{va} = [ \Zs^{a_1} → \Zs_{\bot}] \times [ \Zs^{a_2} → \Zs_{\bot}] \times \dots \times [ \Zs^{a_k} → \Zs_{\bot}]$

\paragraph{Sémantique d'un terme}

Notation : f : $\Zs → \Zs_{\bot}$
Fonctions à une variable x : $f = \lambda x . e$
$\longrightarrow f^* : \Zs_{\bot} → \Zs_{\bot} tq f^*(n) = f(n) \text{ si } n \not = \bot,\ f^*(n) = \bot \text{ sinon}.$
$f^*$ est notée $let x \Leftarrow n,e$

$$\semm{t}_{va} \in [FEnv_{va} → [Env → \Zs_{\bot} ]]$$
$$\semm{n}_{va} \Phi_f = n$$
$$\semm{x}_{va} \Phi_f = f(x)$$
$$\semm{t_1 op t_2}_{va} \Phi_f = (\semm{t_1}_{va} \Phi_f) op_{\bot} (\semm{t_2}_{va} \Phi_f) avec op_{\bot} = op \text{ étendu à } \Zs_{\bot}$$
$$\semm{f_i(t_1, \dots, t_{a_i}}_{va} \Phi_f = let x_1 \Leftarrow \semm{v_1}_{va} $$

\begin{prop}
 Pour tout teme t, $\semm{t}_{va}$ est une fonction continue.
\end{prop}

\begin{prop}
 Si t est clos, $\semm{t}_{va}\ \Phi_f$ ne dépend pas de f.
\end{prop}

Construction de l'environnement $\Phi$ :
$\Phi = (\Phi_1, \dots, \Phi_n)$ solution du système 
\begin{eqnarray}{rcl}
 \Phi_1(n_1, \dots, n_{a_1}) & = & \semm{d_1}_{va} \Phi_p [x_1 ← n_1, \dots, x_{a_1} ← n_{a_1}]\\
\vdots\\
 \Phi_1(n_1, \dots, n_{a_k}) & = & \semm{d_1}_{va} \Phi_p [x_1 ← n_1, \dots, x_{a_1} ← n_{a_1}]
\end{eqnarray}

$\Phi$ est le plus petit point fixe de $Fd$ avec $Fd(\Phi) =$
\begin{eqnarray}{l}
(\lambda n_1 \dots \lambda n_{a_1} \in \Zs . \semm{d_1}_{va} \Phi_f[x_1 ← n_1, \dots, x_{a_1} ← n_{a_1}]\\
\vdots\\
(\lambda n_1 \dots \lambda n_{a_k} \in \Zs . \semm{d_k}_{va} \Phi_f[x_1 ← n_1, \dots, x_{a_k} ← n_{a_k}]
\end{eqnarray}

\begin{ex}
 
\end{ex}


\begin{thm}
  Pour tout terme t clos et tout z \in \Zs, \semm{t}_{va} \Phi_{df} = z ssi t \xrightarrow[va]{d} z
\end{thm}


\subsection{Appel par nom}

Domaines sémantiques inchangés.
FEnv_{no} = [\Zs_{\bot}^{a_1} → \Zs_{\bot}] \times \dots \times [\Zs_{\bot}^{a_k} → \Zs_{\bot}]
n, x, op, if : pareil que pour l'appel par valeur.
\semm{f_i(t_1, \dots, t_{a_i})}_{no} \Phi_f = \Phi_i(\semm{t_1}_{no} \Phi_f, \dots, \semm{t_{a_i}}_{no} \Phi_f)

\begin{prop}
 Pour tout terme t, \semm{t}_{no} est une fonction continue de FEnv_{no} → [Env → \Zs_{\bot}]
\end{prop}
\begin{prop}
 Si t est clos, \semm{t}_{no} \Phi_f ne dépend pas de f.
\end{prop}

Sémantique d'une déclaration :  \Phi_d = Fix F_d avec Fd(Phi) = (\lambda z_1 \dots \lambda z_{a_1} \in \Zs_{\bot} . \sem{\;} \Phi_f [x_1 ← z_1, \dots ]

\begin{rem}
 F_d est continue.
\end{rem}

\begin{ex}
 
\end{ex}


\begin{thm}
 Pour tout terme clos t et tout entier n, \semm{t}_{no} \Phi_{df} = n ssi t \xrightarrow[no]{d} z
\end{thm}


\section{Déclarations locales}

On veut ajouter let f(x) = x+1 in f(x) avec possibilité d'écrire des fonctions récursives.

Syntaxe : on ajoute t ::= let rec f_1(x_1, \dots, x_{a_1}) and \dots and f_k(x_1, \dots, x_{a_k}) in t
\Phi : f_i \mapsto \Phi_i avec \Phi_i \in [ \Zs^{a_i} → \Zs_{\bot}]
\semm{let rec f_1 \dots f_k in t}_{va} \Phi_f = \semm{t}_{va} \Phi' ???? avec \Phi' = \Phi[f_1 ← \Phi'_1, \dots, f_k ← \Phi'_k] et (\Phi'_1, \dots, \Phi'_k) plus petit point fixe de F \Phi
F\Phi (\Psi_1, \dots, \Psi_k) = (\lambda n_1,\dots, \lambda n_{a_1} \in \Zs_{\bot} . \semm{d_1}_{va} \Phi[f_1 ← \Psi_1, \dots, f_k ← \Psi_k] f [x_1 ← n_1, \dots, x_{a_1} ← n_{a_1}] \dots )

il faut montrer que F  \Phi est continue en (Psi_1, \dots, \Psi_k) → Points fixes sur plusieurs variables.
F \Phi dépend de \Phi, on veut pouvoir définir let f(x) = \dots in let g = \dots f \dots in t
\begin{itemize}
 \item jusqu'ici, fonction de \Zs_{a_i} dans \Zs \longrightarrow fonctions en argument ?
 \item \lambda-calcul utilisé pour définir la sémantique des fonctions ? \longrightarrow sémantique du \lambda-calcul ?
 \item 
  \begin{tabular}{rl}
   sémantique axiomatique &: exprimer et prouver des propriétés  → grâce à une fonction logique externe\\
  → autre approche & : preuve = programme, propriété = types
  \end{tabular}
 
\end{itemize}

\part{Types, preuves et programmes}

\section{\lambda calcul simplement typé}

\subsection{Types simples}

\T un ensemble fini de sympbole de types (ex : nat, bool, \dots). Les types simples sont définis inductivement par 
\tau : = T (\in \T) | (\tau → \tau)


\begin{ex}
 \T = \{nat\} → nat, (nat → nat) , \dots
\end{ex}
Syntaxe allégée en parenthèses avec l'associativité à droite implicite.

\subsection{Termes}

On reprend les termes du \lambda calcul
\lambda x .u : la fonction qui à x associe u 
→ son type est <type de x > → <type de u>
\Vs un ensemble infini dénombrable de variables.

\begin{definition}
 L'ensemble des termes est défini inductivement par 
\begin{itemize}
 \item x (\in \Vs) est un terme
 \item si t et t' sont des termes alors (t t') est un terme
 \item si t est un terme, x \in \Vs et \tau un type simple alors 
	\lambda x : \tau . t est un terme (x de type  \tau)
\end{itemize}
On a toujours l'associativité à gauche.
\end{definition}
 

\subsection{Termes bien typés}

\section{Calculer = réduire}

\subsection{Réductions}

\subsection{Normalisation}

\subsection{Ordre de réduction}
avantage de $\forall$ : on va pouvoir typer certaines fonctions récursives.

\subsection{Valeurs usuelles en \lambda calcul}

\section{Preuves}
$
\Gamma \vdash \underbrace{\lambda x : \tau . t}_{\text{programme}} : \underbrace{\tau → \sigma}_{\text{propriété sur le programme}}$

Si on me donne un preuve (x) de la propriété $\tau$, alors je sais construire une preuve t de la propriété $\sigma$.

fonction = transformateur de propriétés (programme)

$\Gamma \vdash t  : \tau$  : il existe une preuve de la propriété $\tau$; le type  $\tau$ est habité; je sais construire un objet t qui vérifie les spécifications données par $\tau$.

Isomorphisme de Curry-Howard :
$\Phi
\begin{array}{lll}
\text{propriété}& → & \text{type} \\
\text{preuve} &\mapsto&  \text{programme}
\end{array}$

$\Phi(A \Rightarrow B) = \Phi(A) → \Phi(B)$

Comment construire une preuve ?
axiomes et règles de déduction : déduction naturelle pour la logique minimale.

axiome $\dfrac{(x,P) \in \Gamma}{\Gamma \vdash x: P}$

abst. $\dfrac{\Gamma, (x:P) \vdash t:Q}{\Gamma  \vdash \lambda x:P.t : P \Rightarrow Q} \text{intro}_{\Rightarrow}$

application $\dfrac{\Gamma \vdash t : P \Rightarrow Q \quad \Gamma \vdash u:P}{\Gamma \vdash (t u) Q}\text{elim}_{\Rightarrow}$

\begin{ex}
 une preuve de $(A \Rightarrow (B \Rightarrow C) \Rightarrow (( A \Rightarrow B) \Rightarrow (A \Rightarrow C))$ est \\
$\lambda x : A → B → C . (\lambda y : A → B. ( \lambda z : A . (x z) (y z)))$
\end{ex}

A quoi ça sert ? 
\begin{itemize}
 \item \og typed programs can't go wrong \fg
 \item types plus riches \begin{ex}
                          fonction $\Phi$ qui prend f et qui retourne un 0 de f.
                          $\Phi: (nat → nat ) → nat$
                          $\Phi: (nat → nat ) → \{ x : nat | f x = 0 \}$ Si je sais construire un programme de ce type, j'ai prouvé en même temps qu'il renvoie bien un zéro de f.
                          Le programme est une preuve de sa spécification.
                         \end{ex}
 \item un programme va contenir : \begin{itemize}
                          \item une partie logique : construction de preuve
                          \item une partie calcul : calculer des \og vraies valeurs \fg
                         \end{itemize}
On peut nettoyer le programme pour ne garder que les calculs utiles : extraction.

\end{itemize}


Conjonction et disjonction

conjonction 
$\dfrac{\Gamma \vdash u:P  \quad \Gamma \vdash v:Q }{\Gamma \vdash <u,v> : P \wedge Q}\text{intro}_{\wedge}$

$\dfrac{\Gamma \vdash r : P \wedge Q}{\Gamma \vdash \Pi_1 r :P }\text{elim}_{\wedge 1}$
disjonction
$\dfrac{\Gamma \vdash u : P \vee Q \quad \Gamma \vdash f: P \Rightarrow R \quad \Gamma \vdash g : Q \Rightarrow R}{\Gamma \vdash case u f g : R}\text{elim}_{\vee}$

$\frac{\Gamma \vdash r: P}{\Gamma \vdash inl r : P \vee Q}\text{intro}_{\vee 1}
\frac{\Gamma \vdash r: Q}{\Gamma \vdash inr r : P \vee Q}\text{intro}_{\vee 1}$

$\begin{array}{l}
case (inl r) f g →_{\beta} f r\\
case (intr r) f g  →_{\beta} g r
\end{array}$ nouvelles $\beta$ réductions


\section{Preuves et calculs}
La $\beta$ réduction ( = le calcul) conserve le type.
Si $t : \tau$ et $t →^*_{\beta} u$ alors $u : \tau$
$t$ et $u$ sont deux preuves de la même propriété.
effet de la réduction : notion de coupure.

\section{Enrichir la logique}

Pouvoir prouver (programmer) plus de choses.

\subsubsection{Polymorphisme et $\forall$}

idée :$ \lambda x . x$ a le type $\alpha → \alpha$ pour tout $\alpha$
on va typer  : $\lambda x .x : \forall \alpha.( \alpha → \alpha) $
$\alpha$ : variable de type.

élimination de $\forall$.

$\frac{\Gamma \vdash u :\forall \alpha . \sigma}{\Gamma \vdash u :\sigma[ \alpha ← \tau]}$
On remplace toutes les occurences libres de $\alpha$ par un type $\tau$ quelconque.

introduction de $\forall$

$\alpha \not \in VarLibres(\Gamma)$
$\dfrac{\Gamma \vdash u : \sigma}{\Gamma \vdash u : \forall \alpha \sigma}$


\subsubsection{Des types qui dépendent de types : $\lambda \underline{\omega}$}
On veut définir $f : = \lambda \alpha : Type . \alpha → \alpha$ language pour construire des types.\\
Les types font partie du language : il faut typer les types.

$\alpha * \beta * \vdash (\alpha → \beta) *$ : si $\alpha$ et $\beta$ sont des types, alors $(\alpha → \beta)$ est un type.

Notion de sorte : type de type (* est une sorte, $* → * \dots → *$ est une sorte)\\
%On ajoute un niveau : $ * : \box , *→* : \box$

\subsubsection{Des types qui dépendent de termes : $\lambda P (LF)$}
Fonctions de type $A^n → B$ (type qui dépend de n)
Tableaux de taille $n : \Pi n : int(vect n) =$ pour tout $n$, je sais construire des tableaux de taille $n$.

En général, : si pour tout $a$ de type $A$, il existe un type $B_a$ non vide, on veut former la fonction $\lambda a : A . b_a : B_a$. Son type est $\Pi a : A.B_a$ produit cartésien des $B_a$.
Si $B_a$ ne dépend pas de $a : B_a = B$.   $\Pi a : A. B = A → B$.

\subsubsection{Cube de Barendregt}

Questions générales sur les sytèmes de types : 
\begin{itemize}
 \item expressivité
 \item cohérence ?( paradoxes)
 \item calculabilité
 \item peut-on calculer dedans ?
 \item efficacité
\end{itemize}


\end{document}
