\documentclass[10pt,a4paper]{article}
\usepackage[french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{pstricks}
\usepackage{mathrsfs}
\usepackage{soul}
\usepackage{newalg}
\usepackage{fullpage}

\usepackage{concrete}
%\usepackage[mathcal,mathbf]{euler}
%\usepackage{ccfonts,eulervm}

\makeatletter
\@addtoreset{section}{part}
\makeatother

\input{../nthmdefs}




\newcommand{\F}{\mathcal{F}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\ssi}{$ ssi $}


\DeclareMathOperator{\bisim}{\underline{\leftrightarrow}}
\DeclareMathOperator{\Ro}{R}
\DeclareMathOperator{\Bo}{B}
\DeclareMathOperator{\Cl}{\mathscr{C}l}
\DeclareMathOperator{\Oo}{\bigcirc}
\DeclareMathOperator{\Fo}{F}
\DeclareMathOperator{\Go}{G}
\DeclareMathOperator{\Uo}{U}
\DeclareMathOperator{\Tr}{tr}

\title{Conception et vérification de programmes}
\author{François Schwartzentrüber\\
\url{inria.fr/prive/fschwarz/cvfp}}
\date{}


\begin{document}
\renewcommand{\labelitemi}{$\bullet$}

\maketitle

\part{Petite introduction}

\section{Machines de Turing}

\begin{definition}[Machine de Turing] Une machine de Turing est un $M = ( \Sigma , Q , \delta, s)$ tel que \begin{itemize}
\item $\Sigma$ est un alphabet fini
\item Q est un ensemble d'états fini non vide
\item $\delta \subseteq (Q \times \Sigma) \times (Q \cup \{yes \} \times \Sigma \times \{-1, 0, 1\}$
\item $s \in Q$
\end{itemize}
On dit que M est déterministe si $\forall q \in Q, \forall a \in \Sigma,$

$\mid \{ (q', b, d) \mid (q, a, q', b, d) \in \delta \} \mid \leq 1$
\end{definition}

\subsection{Executions}
\begin{definition}[Configuration]
Une configuration est un triplet $(q, k, w)$ où \begin{itemize}
\item $q$ est un état
\item $k \in \Ns$
\item $w$ est un mot fini sur $\Sigma$
\end{itemize}
\end{definition}

\begin{definition}[Transition]
$(q, k, w) \rightarrow (q', k', w')$ ssi $(q, \sigma, q', \sigma', dir) \in \delta$ et \begin{itemize}
\item $w[k] = \sigma$
\item $w' = w$ sauf $w'[k] = \sigma'$
\item $k' = k + dir$
\item $k' \geq 0$
\end{itemize}\end{definition}

\begin{definition} Soient c, c' deux configurations, \begin{itemize}
\item $c \rightarrow^0 c$
\item $ \forall t \geq 1, \; c \rightarrow^t c' $ ssi $ \exists c'' \tq c \rightarrow^{t-1}c''$ et $c'' \rightarrow c'$
\item $c \rightarrow^* c'$ ssi $\exists t \geq 0 \tq c \rightarrow^t c'$
\end{itemize} \end{definition}

\subsection{Décision} 

 \begin{definition}
M décide un language $L \subseteq \Sigma^*$ ssi 

$\forall x \in \Sigma^*, x \in L$ ssi $\exists k \geq 0, w \in \Sigma^* \tq[s] (s, 0, x) \rightarrow^* (yes, k, w)$\\
  \end{definition}

 \begin{definition}
 Soit $f : \Ns\to \Ns$, \quad $M$ décide $L$ en temps $f$ ssi $M$ décide $L$ et 

$\forall t \in \Ns, \forall x \in \sigma^*, \quad (s, 0, x) \rightarrow ^t (q, k, w) \Rightarrow t \leq f( | x | )$\\
 \end{definition}

\begin{prop}
 Soit $M$ qui décide $L$ en temps $f$, 

si $(s, 0, x \rightarrow^* (q, k, w)$, alors $ | w |  \leq max (  | x | , f( | x | )$
\end{prop}
 \begin{dem}
  Au temps $t$, $\forall k' > max (  | x | , t), w[k'] )$ est vide et le curseur courant $k \leq t$\\
 \end{dem}

 \section{Complexité en temps}
 
 \begin{definition}{}\begin{itemize}
 \item $P$ est la classe des langages $L$ tels qu'il existe $f$ polynôme et $M$ machine déterministe\tq[s] $M$ décide L en temps $f$
\item $NP$ : $M$ non detéterministe
\item $EXPTIME$ : $f$ polynome, $M$ machine déterministe, $M$ décide $L$ en temps~$2^f$
 \item $NEXPTIME$ : $M$ non déterministe
 \end{itemize}
 \end{definition}


 \subsection{Difficultés}
 \begin{definition}{}$L'$ réductible en temps polynomial à $L$ ssi il existe $f$, calculable en temps polynomial $\tq[le]$

$\forall x \in \Sigma ^*, \; x \in L' \Leftrightarrow f(x) \in L$
 \end{definition}
 \begin{definition}{}$L$ est $NP$-dur ssi pour tout $L' \in NP$, on a $L'$ réductble en temps polyomial à~$L$.\\
 $L$ est $NP$-complet ssi $L \in NP$ et $L$ est $NP$-hard.
 \end{definition}
\begin{rem} 
Si $L$ est $NP$-hard et  $L \in P$, alors $NP = P$
\end{rem}
 
\begin{prop}
 Soit $L \in NP$-dur, si $L$ réductible en temps polynomial à $L'$, alors $L'$ est $NP$-dur.\\
Soit $L' \in NP$, $L$ réductible à $L' \Leftrightarrow L \in NP$
\end{prop}
 
 \begin{definition}$CO\,NP$ est l'ensemble des $L \tq \Sigma^* \setminus L \in NP$
 \end{definition}
 \section{Pavages et logique proportionnelle}
 
 \subsection{Pavages} 
\begin{definition}
Un type de pavé t est un quadruplet 

$< left(t), top(t), right(t), down(t) >~ \in~ \Ns^4$.\\
 $TILING$ est le problème suivant : \begin{itemize}
 \item entrée : $T$ ensemble fini de types de pavé $t_1, ..., t_n \in T$
\item sortie : oui si $\exists \mu : \{ 1, ..., n\} ^2 \rightarrow T \tq$ 
\begin{itemize}
\item $\exists j \in \{1, .., n\}, \mu(1,j) = t_j$
\item $\forall i < n, \forall j < n, \; down(\mu(i,j)) = up(\mu(i+1, j))$
\item $\forall i \leq n , \forall j < n, \; right (\mu (i,j)) = left( \mu (i, j+1))$
\end{itemize}
\end{itemize}
\end{definition}

\begin{thm}
 TILING est NP hard
\end{thm}

\begin{thm}
  SAT est NP-hard
\end{thm}


\begin{dem}
 On transforme une instance du pavage en une formule $\Phi$ de la logique prop. en encodant les contraintes avec les variables $p_{i,j,t}$ pour $\mu(i,j) = t$.
\end{dem}



\section{Complexité en espace}
\begin{definition}{}$L$ est dans PSPACE ssi $\exists M$ machine déterministe et $f$ un polynome tels que \begin{itemize}
\item $M$ décide $L$
\item $\forall x \in \Sigma^*, \quad (s,0,x) \rightarrow^* (q, k, w) \Longrightarrow  | w |  \leq f( | x | )$
\end{itemize}\end{definition}
\begin{definition}{}L est dans NPSPACE ssi $\exists M$ machine non déterministe, $f$ un polynome tels que \begin{itemize}
\item $M$ décide $L$
\item $\forall x \in \Sigma^*, \quad (s,0,x) \rightarrow^* (q, k, w) \Longrightarrow  | w |  \leq f( | x | )$
\end{itemize}\end{definition}
\begin{definition}{}L est dans EXPSPACE ssi $\exists M$ machine déterministe, $f$ un polynome tels que \begin{itemize}
\item $M$ décide $L$
\item $\forall x \in \Sigma^*, \quad (s,0,x) \rightarrow^* (q, k, w) \Longrightarrow  | w |  \leq 2^{f( | x | )}$
\end{itemize}\end{definition}
\begin{definition}{}L est dans NEXPSPACE ssi $\exists M$ machine non déterministe, $f$ un polynome tels que \begin{itemize}
\item $M$ décide $L$
\item $\forall x \in \Sigma^*,  \quad (s,0,x) \rightarrow^* (q, k, w) \Longrightarrow  | w |  \leq 2^{f( | x | )}$
\end{itemize}\end{definition}
\begin{rem}
 Normalement, les classes de complexité en espace se définissent avec une machine de Turing à plusieurs rubans.
\end{rem}

\section{Un autre pavage}
CORRIDOR TILING est défini par :
\begin{itemize}
\item entrée : $T$ ensemble fini de type de pavé, et $t_1, ..., t_n, b_1, ..., b_n$ deux séquences de types de pavés
\item sortie : oui si on peut paver 
$\begin{array}{c| c| c | c | c | c}
t_1 & & & & & t_n\\
 \hline
& & & & & \\
& & & & & \\
& & & & & \\
& & & & & \\
b_1 & & & & & b_n
\end{array}$ n fois $2^n$
\end{itemize}

\begin{definition}{}$L \in PSPACE$-hard ssi pour tout $L'$ dans $PSPACE, L'$ est réductible en temps polynomial à $L$
\end{definition}
\begin{thm}
 CORRIDOR TILING est $NPSAPCE$-hard
\end{thm}

\begin{dem}
 
 Soit $L$ dans NPSPACE, il existe $M$ machine non déterministe et $f$ un polynome, tels que \begin{itemize}
\item $M$ décide $L$
\item $M$ utilise un espace mémoire en $f$
\end{itemize}
On suppose de plus que la machine efface son ruban si elle accepte x et arrive sur $(yes, 0, \varepsilon)$.\\
Considérons les exécutions possibles de $M$ sur $ | x | $. Le nombre de configs possibles est au plus $  |  Q  |  \times f( | x | ) \times  (1 +  | \Sigma | )^{ f ( | x |) }$\\
Si $M$ accepte $x$, il existe une exécution de longueur au plus $c^{f( | x | )}$ où $c$ est une constante. On peut donc encoder cette exécution dans un pavage :\\
\[2 ^{\log_2( c) f( | x | )} = c^{f (| x |) } \underbrace{
\left\{
\begin{array}{ |c c c| }
\cline{1-3}
t_1 &\dots & t_n \\
 \cline{1-3}
&& \\
&& \\
\cline{1-3}
& & \\
\cline{1-3}
\end{array}
\right. }_{\log_2 (c) f(|x|)}
\begin{array}{l }
←\text{encode la config initiale} \\
\\
\\
 ← \text{encode }(yes, 0, \varepsilon)\\
\end{array} \\
\]

\end{dem}

\section{Logique proportionnelle quantifiée}
Problème SAT : est ce qu'il existe une valuation $\mu$ telle que $\mu \models \Phi$ ?

Problème VALID : est ce que pour toute valuation $\mu$ on a $\mu \models \Phi$ ?

\begin{definition}
 
 Une formule de la logique prop quantifiée (QBF, quantifiable binary formula) est une formule de la forme :

 $\exists p_1, \forall p_2, \exists p_3 ... Q_np_n \Phi$ où
$\begin{array}{l}
Q_n \in \{ \exists, \forall \}\\
\Phi$ est une formule de la logique propositionnelle.$
\end{array}$

\end{definition}

\begin{definition}On définit $\mu \models \Phi$ pour $\Phi$ de la logique prop quantfiée \begin{itemize}
\item $\mu \models \exists p \,\Phi$ ssi $\mu [ p := 0] \models\Phi$ ou $\mu [p := 1] \models \Phi$
\item $\mu \models \forall p \, \Phi$ ssi $\mu [ p := 0] \models\Phi$ et $\mu [p := 1] \models \Phi$
\item $\mu \models  \Phi$ habituel pour $\Phi$ propositionnel
\end{itemize}\end{definition}

\begin{thm}

Le problème QBF-sat tel que
\begin{itemize}
 \item L'entrée est $\Phi = \exists p_1 \forall p_2 \dots Q_n p_n \, \Psi$, \\
où $p_1 p_2 \dots p_n$ sont les variables qui apparaisent dans $\Psi$.
\item La sortie est oui si $\Phi$ est vrai(ie $\mu \models \Phi, \mu$ quelconque)
\end{itemize}
est $NPSPACE$-hard.
\end{thm}

\begin{dem}[diviser pour régner]

but:  transformer une instance de CORRIDOR TILING en $\Phi$ de la logique prop quantifiée telle que
$ 2^n  \left\updownarrow
\begin{array}{|ccc|}
 \hline
t_1 & \dots & t_n \\
\hline
&&\\
&&\\
\hline
b_1 & \dots & b_n \\
\hline
\end{array} \right. $
 pavable ssi $\Phi$ est vraie.\\
De plus $\Phi$ doit être de taille polynomiale par rapport à l'instance:\\ → c'est là que DPR est nécéssaire.

On note $\vec{p_a} = (p_a, j, t)_{j \in { 1, ..; n}, t \in T}$ : cela permet de décrire une ligne du pavage.

1ere idée : Définir $\Phi_k (p_a, p_b)$ qui encode le fait qu'il existe un pavage $n \times 2^k , p_a$ 1ere ligne, $p_b$ dernière ligne.
On définit $\Phi_1 (p_a, p_b) = \dots$\\
Par récurence, $\Phi_k(p_a, p_b) = \exists p_c, p_d \tq \Phi_{k-1} (p_a, p_c) \wedge \Phi_1(pc, pd) \wedge\Phi_{k-1}(p_d, p_b) \forall k \geq 2$

Problème : $\Phi_n$ va être de taille exponentielle

2eme idée : (la bonne)\\
$\Phi_1 (p_a, p_b) = ...$\\
$\Phi_k(p_a, p_b) = \exists p_c, p_d \tq \Phi_1(pc, pd)$ et $\forall p_q, p_r , (((p_q \Leftrightarrow p_a) et (p_r \Leftrightarrow p_c)$ ou $(p_q \Leftrightarrow p_d) et (p_r \Leftrightarrow p_b))\\
 \Rightarrow \Phi_{k-1} (p_q, p_r)$


Par exemple $p_q \Leftrightarrow p_a$ est un raccourci pour $\bigwedge_{j=1}^n \bigwedge t \in T (p_{q,j,t} equiv p_{a, j, t}$
\end{dem}
\begin{thm}
$QBF sat$ est $PSPACE$
\end{thm}

\begin{center}\begin{minipage}{1pt}
\begin{algorithm}{qbf-sat}{\mu, \Phi}
\begin{SWITCH}
 \item{\Phi = \exists p \, \Psi} \\
  \RETURN \CALL{qbf-sat}(\mu [p:=0], \Psi) \text{ ou }\CALL{qbf-sat} (\mu[p:=1], \Psi)
  \item{\Phi = \forall p \, \Psi} \\
  \RETURN  \CALL{qbf-sat}(\mu [p:=0], \Psi)$ et $\CALL{qbf-sat} (\mu[p:=1] \Psi)
\item{\Phi$ propositionnel $}\\
  \RETURN $oui ssi $\mu \models \Phi
\end{SWITCH}
\end{algorithm}
\end{minipage}\end{center}

\begin{dem} [thèse de church]

\textsc{qbf-sat} s'exécute en espace polynomial

\end{dem}

Bilan : 
\begin{thm}[de Savitch]
 $PSPACE = NPSPACE$
\end{thm}
\begin{dem}
 Soit $L \in NPSPACE$. Comme \textsc{qbf-sat} est $NPSPACE$-hard, il existe une fonction $f$ calculable en temps polynomial telle que
 $\forall c \in \Sigma^*, x \in L$ ssi la QBF $f(x)$ est vraie.

Voici une machine déterministe qui décide de $L$ en espace polynomial :

\begin{algorithm}{décider L}{x}
 \RETURN \CALL{qbf-sat}{(f(x))}
\end{algorithm}

Donc $L \in PSPACE$.
\end{dem}


\part{Logique modale}

\section{La logique modale K (Kripke)}

\subsection{Syntaxe}

Soit $ATM$ un ensemble dénombrable de propositions atomiques.
\begin{definition}
 Le langage de la logique modale K est défini par la BNF suivante :

$\Phi ::= \perp  |  p  |  \lnot \Phi  |  \Phi \vee \Phi  |  \Box \Phi$ où $p \in ATM$
\end{definition}

\begin{definition}
 L'axiomatique de la logique K est constituée
\begin{itemize}
 \item d'axiomes : \begin{itemize}
                  \item tautologies de la logique classique
                  \item $\Box (\Phi \rightarrow \Psi) \rightarrow ( \Box \Phi \rightarrow \Box \Psi)$ (Axiome K) 
                 \end{itemize}
 \item de règles : \begin{itemize}
                 \item le modus ponens : $ \dfrac{ \Phi \qquad \Phi \rightarrow \Psi }{ \Psi}$
                 \item la nécessitation : $ \dfrac{ \Phi }{ \Box \Phi }$
                \end{itemize}
\end{itemize}
\end{definition}

\begin{definition}
 $\Phi$ est prouvable ssi il existe $ \Phi_1 \cdots \Phi_n \tq \forall i \in \{1, \cdots , n \},$
\begin{itemize}
 \item soit $ \Phi_i$ est l'instance d'un axiome
 \item soit $ \Phi_i$  est obtenue à partir d'une des règles et de $ \Phi_j$, où $j < i$ et $ \Phi_n = \Phi$
\end{itemize}
On écrit $ \models \Phi$ pour $ \Phi$ est prouvable ( $ \Phi $ est un théorème).
\end{definition}

\begin{definition}[$\vdash$]
 Soit $ \Sigma$ un ensemble de formules, $ \Phi$ une formule. 

$ \Sigma \vdash \Phi$ ssi $ \exists \Psi_1, \cdots, \Psi_n \in \Sigma \tq \\
\vdash ( \Psi_1 \wedge \cdots \wedge \Psi_n) \rightarrow \Psi$
\end{definition}

\subsection{Sémantique de Kripke}

\begin{definition}[Cadre de Kripke]
 Un cadre de Kripke est un couple $\F = (W, R)$ où :
\begin{itemize}
 \item $W$ est un ensemble non vide de mondes possibles
 \item $ R \subseteq W \times W$ est une relation entre les mondes
\end{itemize}
\end{definition}

\begin{rem}
 Si on a plusieurs opérateurs \fbox{$\,i\,$}, $i \in I$ dénombrable, $R$ est remplacé par une collection de relations $(R_i)_{i \in I}$
\end{rem}

\begin{definition}[Modèle de Kripke]
 Un modèle de Kripke est un couple $ \M = (\F, V)$ où
\begin{itemize}
 \item $ \F$ est un cadre
 \item $ V : ATM \rightarrow 2^W$
\end{itemize}
\end{definition}

\begin{definition}[$\models$]
 Soient $ \M = (W,R,V)$ un modèle de Kripke, $w \in W$ et $ \Phi$ une formule.

On définit $ \M, w \models \Psi$ par induction sur $ \Psi$ :
\begin{itemize}
 \item $ \M, w \not \models \perp$
 \item $ \M, w \models p$ ssi $w \in V(p)$
 \item $ \M, w \models \Psi \vee \Phi$ ssi $ \M,w \models \Psi$ ou $ \M, w \models \Phi$
 \item $ \M, w \models \fbox{\,i\,} \Phi$ ssi $ \forall v \in R_i(w), \M, v \models \Phi$
\end{itemize}

\end{definition}


\begin{itemize}
 \item La donnée de $ \M, w $ s'appelle un modèle pointé.
 \item On dit que $ \Phi $ est satisfiable ssi \\il existe un modèle pointé $ \M, w  \tq \M, w \models \Phi$
 \item On dit que $ \Phi $ est valide ssi pour tout modèle pointé $\M, w$, on a $\M, w \models \Phi$
 \item Soit $ \Sigma$ un ensemble de formules. On écrit $ \M, w \models \Sigma$ pour tout que $ \forall \Phi \in \Sigma$, on a $\M, w \models \Phi$.
 \item On dit que $ \Phi$ est conséquence de $ \Sigma$ ssi pour tout modèle pointé $ \M, w$, on a $\M, w \models \Sigma$ implique $\M, w \models \Phi$.
\end{itemize}



\begin{prop}
 Si $ \vdash \Phi$ alors $ \models \Phi$
\end{prop}
\begin{dem}
 Par induction sur la longueur de la preuve : \\
on montre que les axiomes sont valides et que les règles préservent la validité.
\end{dem}


\textbf{Expressivité :}

\begin{ques}[1]
Est-ce qu'il existe $ \Phi$ modale telle que $ \M, w \models \Phi \Leftrightarrow R(w) = \empty $ ?\\
$\hookrightarrow$ oui : $ \Phi = \lnot \Diamond \top$ ou $ \Phi = \Box \bot$\end{ques}
\begin{ques}[2]Est-ce qu'il existe $ \Phi$ modale telle que $ \M, w \models \Phi \Leftrightarrow w R w$ ?\\
$\hookrightarrow$ plus dur, on va voir ça.\end{ques}

\section{Bisimulations}

\begin{definition}[bounded morphism] Soient $ \M = (W,R,V)$ et $ \M' = (W',R',V')$ deux modèles.\\
 $ f : W \to W'$ est un \og bounded morphism \fg  ssi
\begin{enumerate}
 \item $ \forall w \in W, \quad w$ et $f(w)$ satisfont les mêmes propositions
 \item $ \forall w,u \in W,\quad w R u \Rightarrow f(w) R' f(u)$
 \item $\forall w \in W, u \in W',\quad  f(w) R' u' \Rightarrow \exists u \in R(w)$ et $u' = f(u)$
\end{enumerate}
\end{definition}

On va montrer que si il existe un \og bounded morphism \fg $f$ de $W$ dans $W'$, alors $ \M,w$ et $ \M',w'$ satisfont les mêmes formules modales.

\begin{definition}[bisimulation]
 Soient $ \M = (W,R,V)$ et $ \M' = (W',R',V')$ deux modèles.\\
Une relation non vide $ B \subseteq W \times W'$ est une bisimulation ssi :
\begin{itemize}
 \item $ w   \Bo w' \Rightarrow w$ et $w'$ satisfont les mêmes propositions.
 \item $w   \Bo w' \wedge w   \Ro u \Rightarrow \exists u'$ tel que $w'   \Ro u'$ et $u   \Bo u'$
 \item $w   \Bo w' \wedge w'   \Ro u' \Rightarrow \exists u$ tel que $w   \Ro u$ et $u   \Bo u'$
\end{itemize}

\end{definition}

\begin{definition}
 $ \M,w$ et  $ \M',w'$ sont bisimilaires ssi $ \exists B$ bisimulation entre $ \M$ et $ \M' \tq w   \Bo w'$.\\
On note $ \M,w \bisim \M', w'$
\end{definition}

\begin{thm}
 Si $ \M,w \bisim \M', w'$, alors ils satisfont les mêmes formules modales.
\end{thm}

\begin{dem}
 Par induction sur $ \Phi$, on montre\\
$ \mathcal{P}( \Phi)= $ \og Si $ \M,w \bisim \M', w'$ alors $ \M,w \models \Phi$ ssi $ \M',w' \models \Phi$ \fg
\end{dem}

\begin{definition}[modèle à images finies]
 Soit $ \M = (W,R,V), \quad\M$ est à images finies ssi $ \forall w \in W, R(w)$ est fini.
\end{definition}

\begin{prop}
 Soient $ \M, \M'$ à images finies,
si $ \M, w$ et $ \M', w'$ satisfont les mêmes formules modales, alors  $ \M,w \bisim \M', w'$.
\end{prop}
\begin{dem}
 Soit $ \leftrightsquigarrow$ la relation définie par $w \leftrightsquigarrow w'$ ssi $ \M, w$ et $ \M', w'$ satisfont les mêmes formules modales.\\
Montrons que $ \leftrightsquigarrow$ est une bisimulation :

\end{dem}

\section{Logique modale et premier ordre}

On définit une traduction de la logique modale dans la logique du premier ordre (avec deux variables) :

Soient $x,y$ deux variables, on définit $ST_x, ST_y$ de la façon suivante :\\
\begin{center}
 
$ \begin{array}{l | l}
  ST_x( \bot) = \bot & ST_y( \bot) = \bot \\
  ST_x( p) = p(x) & ST_y( p) = p(x) \\
  ST_x( \lnot \Phi) = \lnot ST_x( \Phi) & ST_y( \lnot \Phi) = \lnot ST_y( \Phi) \\
  ST_x( \Phi \wedge \Psi) = ST_x( \Phi) \wedge ST_x(\Psi) & ST_y( \Phi \wedge \Psi) = ST_y( \Phi) \wedge ST_y(\Psi)\\
  ST_x( \Box \Phi) = \forall y, x R y \rightarrow ST_y( \Phi) & ST_y( \Box \Phi) = \forall x, y R x \rightarrow ST_x( \Phi) \\
  \end{array}
$

\end{center}

\begin{prop}
 Soient $ \M = (W,R,V)$ et $ \Phi$ modale. \\
On a $ \M,w \models \Phi$ ssi $ \M [x \Leftarrow w] \models_{\text{ \tiny{1\ier ordre}}} ST_y( \Phi)$
\end{prop}
\begin{rem}
 $\M [x \Leftarrow w]$ est un modèle du 1\ier ordre, avec 
\begin{itemize}
 \item $W$ comme domaine 
 \item le prédicat $R$ est interprété par $R$
 \item les prédicats $p(.)$ s'interprètent avec $V$
\end{itemize}

\end{rem}

\begin{rem}
 Le problème de la satisfiabilité du 1\ier ordre avec deux variables est décidable et $NEXPTIME$-complet.\\
$ \hookrightarrow$ le problème $SAT$ de K est décidable.
\end{rem}

\begin{thm}[caractérisation de Von Benthem]
 Soit $ \alpha(x)$ une formule du 1\ier ordre (avec $x$ une variable libre) formée à partir de $R$ (prédicat binaire) et de prédicats unaires.\\
On a équivalence entre
\begin{itemize}
 \item $ \alpha(x)$ est équivalente, par bisimulation , i.e. : \\
( Si $ \M,w \bisim \M', w'$, alors \\
$ \M [x \Leftarrow w] \models  \alpha(x)$ ssi $ \M' [x \Leftarrow w'] \models  \alpha(x)$ )
\item $ \alpha(x)$ est équivalente à $ST_x( \Phi)$ où $ \Phi$ modale.
\end{itemize}
\end{thm}

\paragraph{Problème sat}:
\begin{description}
 \item[entrée : ] $ \Phi $ modale
 \item[sortie : ]oui ssi $ \Phi $ est satisfiable
\end{description}

\begin{definition}[degré modal]
 Soit $d(.)$ le degré modal défini par 
\begin{itemize}
 \item $d( \bot) = d( p) = 0$
 \item $ d( \lnot \Phi) = d( \Phi)$
 \item $ d( \Phi \vee \Psi) = \max( d( \Phi), d( \Psi)$
 \item $ d( \Box \Phi) = 1 + d( \Phi)$
\end{itemize}

\end{definition}

\begin{definition}[ensemble clos]
 Un ensemble est dit clos ssi il est clos par sous formule et par négation (après simplification des $\lnot \lnot$).\\
On note $\Cl(\Gamma)$ le plus petit ensemble clos contenant $ \Gamma$.
\end{definition}

\begin{prop}
 $\displaystyle  | \Cl(\Gamma) | \leq 2 \sum_{\Phi \in \Gamma}  |  \Phi  | $  
\end{prop}

\begin{definition}[ensemble de Hinitkka]
Soit $\Sigma$ un ensemble clos. $H$ est un ensemble de Hintikka ssi H maximal et vérifie :
\begin{itemize}
 \item $H \subseteq \Sigma$
 \item $\bot \not \in H$
 \item $\forall \lnot \Phi \in \Sigma, \; \lnot \Phi \in H$ ssi $\Phi \not \in H$
 \item $\Phi \vee \Psi \in H$ ssi $\Psi \in H$ ou $\Phi \in H$
\end{itemize}

\end{definition}

Voici un algorithme non déterministe pour décider la satisfiabilité de $\Gamma$, un ensemble fini de formules  :

\begin{algorithm}{satK}{\Gamma}
 H \= \CALL{saturerHintikka}(\Gamma)\\
    \begin{FOR}{$tout $ \lnot \Box \Phi \in H}
	 \CALL{satK}( \{ \lnot \Phi \} \cup \Box^{-1} H)
    \end{FOR}\\
    \RETURN $Succès$
\end{algorithm}\\
où $\Box^{-1} H = \{ \Phi, \Box \Phi \in H\}$\\
\begin{algorithm}{saturerHintikka}{\Gamma}
  H \= \CALL{choisir}_{ND} \;\Gamma \subseteq H \subseteq \Cl(\Gamma)\\
  \begin{IF}{H$ est un ensemble de Hintikka$}
      $Succès$
  \ELSE
      $Echec$
\end{IF}
\end{algorithm}

\begin{dem}[$NPSPACE$]
 On pose $d(\Gamma) = max (d (\Phi))$
\end{dem}
\begin{thm}
 L'algo termine
\end{thm}
\begin{dem}
 $d( { \lnot \Phi } \cup \Box^{-1} H) < d( \Gamma)$
\end{dem}

\begin{thm}
 Si $satK(\Gamma)$ réussit alors $\Gamma$ satisfiable
\end{thm}
\begin{dem}
 Cas de base : $d(\Gamma) = 0 : \Gamma$ propositionnel !

Soit $\mu :
\begin{array}{ccl}
 ATM & \rightarrow&  {0,1}\\
	p & \mapsto&  1$ ssi $p \in H
\end{array}$\\

On montre que $\mu \models \Phi$ ssi $\Phi \in H$.

Cas inductif : \\
Considérons un appel $satK(\Gamma)$ qui réussit. Par induction, tous les appels $satK( \{ \lnot \Phi \} \cup \Box^{-1} H)$ ayant réussi, les formules sont satisfiables.\\
On construit un modèle $\M$= $(\M_i)$ modèles des appels récursifs et $w$ défini à partir de $H$.

On montre que $\M,w \models \Gamma$.
\end{dem}

\begin{thm}
 $\Gamma$ satisfiable $\Rightarrow satK( \Gamma)$ réussit.
\end{thm}

\begin{dem}
 On part d'un modèle $(\M,w)$:\\
 Considérons l'exécution où $H = \{\Phi \in CL(\Gamma) \tq[s] \M,w \models \Phi \}$
(c'est un ensemble de Hintikka).\\
Chaque $\Gamma' = \{ \lnot \Phi \} \cup \Box^{-1} H$ est satisfiable dans un successeur de $w$.\\
$\Rightarrow$ les appels récursifs réussissent.\\
$\Rightarrow satK( \Gamma)$ réussit.
\end{dem}

\part{Correspondance sur les cadres}

\section{Définissabilité}

\begin{definition}[cadre]
 Un cadre est un couple $\F = W, R$ où $W$ est un ensemble de mondes possibles, et $R \subseteq W \times W$
(c'est un modèle sans la valuation)
\end{definition}

\begin{definition}[$\models_{\text{cadre}}$]
 Soient $\F = (W,R)$ un cadre et $w \in W$.
\begin{itemize}
 \item $\F, w \models \Phi$ ssi pour tout modele $\M = (\F, V)$ basé sur $\F$, on a $\M,w \models \Phi$
 \item $\F \models \Phi$ ssi pour tout $w \in W, \; \F, w \models \Phi$
\end{itemize}
\end{definition}
On va s'intéresser à des classes de cadres,  par exemple : 
$C_{\text{réflexifs}}$ = classe des cadres où $R$ est réflexive.

\begin{definition}
 Soient $C$ une classe de cadres et $\Phi$ une formule.

$\Phi$ définit $C$ ssi pour tout cadre $\F,\F \in C \Leftrightarrow \F \models \Phi$
\end{definition}

\begin{ex}
 $p \Rightarrow \Diamond p ($ ou $\Box p \rightarrow p)$ définit $C_{\text{réflexifs}}  $
\end{ex}


\section{Premier / Second ordre}

\begin{prop}
 Soit $\Phi$ une formule modale.

$\F,w \models Phi$ ssi $\F[x \leftarrow w] \models \forall p_1, \dots, p_n ST_x (\Phi)$
\end{prop}

\begin{ex}
 $\F,w \models p \rightarrow \Diamond p$ ssi $\F[x \leftarrow w] \models \forall p, p(x)  \rightarrow \exists y, x   \Ro y \wedge p(y)$.\\
Mais on a aussi $\F,w \models p  \rightarrow \Diamond p$ ssi $\F[x \leftarrow w] \models \forall y , y   \Ro y$.\\
On dit que $p \rightarrow \Diamond p$ correspond à une propriété du 1\ier ordre, à savoir $\forall y , y   \Ro y$.
\end{ex}

\begin{ques}
 est ce que $\Phi$ modale correspond toujours à une formule du 1\ier ordre ? 
\end{ques}

\section{Des formules récalcitrantes}

\subsection{Formule de Löb}
$\Phi = \Box ( \Box p \rightarrow p) \rightarrow \Box p$
(provient de la logique de la prouvabilité : $\Box p$ signifie $p$ prouvable).\\
$C_{\text{Löb}}$ = classe des cadres où $R$ est transitive et $R^{-1}$ est bien fondée (i.e. il n'existe pas de séquence infinie $w_0   \Ro w_1   \Ro w_2   \Ro \dots$ )

\begin{prop}
$ \F \models \Phi$ ssi $\F \in C_{\text{Löb}}$
\end{prop}
\begin{dem}
 
\end{dem}

\begin{prop}
 Il n'existe pas de formule $\alpha$ du 1\ier ordre telle que

$\F \in C_{\text{Löb}} \Leftrightarrow \F \models \alpha$
\end{prop}
\begin{dem}
 
\end{dem}

\subsection{Formule de Mc Kinsey}
\begin{prop}
 Soit $\Phi = \Box \Diamond p \rightarrow \Diamond \Box p, \Phi$ ne correspond à aucune propriété du 1\ier ordre \\( $\not \exists \alpha  \tq \forall \F, \F \models \Phi$ ssi $\F \models \alpha$)
\end{prop}

\begin{dem}
 T.D.
\end{dem}


\section{Propriété du premier ordre non définissable}
\begin{prop}
 $\exists x, x   \Ro x$ n'a pas de correspondance en logique modale, ie $\not \exists \Phi$ modale tq $\F \models \exists x, x   \Ro x \Leftrightarrow \F \models \Phi$
\end{prop}

\begin{dem}
 T.D.
\end{dem}


\section{Vers un algo pour trouver l'équivalent en 1\ier ordre}

\subsection{Un fragment stupide}

\begin{prop}
 Si $\Phi$ ne contient pas de proposition, alors $\F, w \models \Phi$ ssi $\F[x \leftarrow w ] \models ST_x(\Phi)$
\end{prop}

\subsection{Les formules uniformes}

\begin{definition}[occurence positive]
une occurence de $p$ est positive si elle est dans la portée d'un nombre pair de négations.\\
$\Phi$ est positive en $p$ ssi toutes les occurences de $p$ sont positives.
\end{definition}

\begin{definition}[formule croissante]
 $\Phi$ est croissante en $p$ ssi $\forall \,\F = W, R, \;\forall \, V, V'$, on a :\\
$V(p) \subseteq V'(P)$ et $\forall q \not = p, V(q) \subseteq V'(q) $

 $ \Rightarrow \F, V, w \models \Phi$ implique $\F, V', w \models \Phi$
\end{definition}

\begin{prop}
 $\Phi$ positive en $p \Rightarrow \Phi$ croissante en $p$\\
$\Phi$ négative en $p \Rightarrow \Phi$ décroissante en $p$
\end{prop}
\begin{dem}
 T.D.
\end{dem}

\begin{rem}
 ça roule ??? idem sur le second ordre.
\end{rem}


\begin{cor}
Soit $\Phi$ négative en $p, \\
\begin{array}{ll}
 & (\F, w, \models \Phi )\\
\Leftrightarrow & (\forall V, (V(p) = W) \Rightarrow \F, V, W \models \Phi)\\
\Leftrightarrow & (\F, w \models \Phi [p \leftarrow \top])
\end{array}$
\end{cor}


\begin{definition}[formule uniforme]
 Une formule $\Phi$ est uniforme ssi $\forall p, \Phi$ est soit positive, soit négative en $p$
\end{definition}

\begin{prop}
 Si $\Phi$ est uniforme, alors $\Phi$ correspond à une formule modale $\Psi$  où on a remplacé les occurences positives par $\bot$ et négatives par $\top$. $\Phi$ correspond à $\forall x, ST_x( \Phi)$
\end{prop}



\subsection{Formule de Sahlquist}
On définit une construction syntaxique $S ::= X \Rightarrow POS$\\
où POS est une formule positive et $\chi ::= \top  |  \bot  |  \Box_{i_1} \cdots \Box_{i_n}p  |  \chi \wedge \chi  |  \Diamond_{j_i} \chi$.
La formule générée par S
\begin{thm} Soit $\Phi$ une formule de Sahlquist. Il existe une formule du 1er ordre $\alpha$ qui correspond à $\Phi$ sur les cadres.\\
Pour tout cadre $\F$, pour tout monde $w$,

$\F, w \models \Phi$ ssi $\F[x \leftarrow w] \models \alpha(x)$
\end{thm}

\begin{ex}{1}\\
$ \F, m \models \Phi$ \\
ssi $\forall V, \; \F, V, m \models \Phi$\\
ssi $\forall V, \;\F, V, w \models p$ implique $\F, V, w \models \Diamond p$\\
ssi $\forall V, \; w \in V(p)$ implique $\F, V, m \models \Diamond p$\\
ssi $\forall V',\; V'(p) = {w}$ implique $\F, V, w \models p$\\
ssi $\forall V', \; V'(p) = \{ w \}$ implique $\F, V, w \models \Diamond p$
(car $\Diamond p$ est croissante en p car positive)\\
(1) ssi $\forall V' \tq V'(p) = w$, on a $\F[x \leftarrow w ], V' \models \exists y, x  \Ro y \wedge p(y)$\\
ssi le prédicat p est interprété avec la fonction 
$\left |  \begin{array}{lcl}
 W & \longrightarrow& \{0, 1\}\\
 w & \mapsto & \left\{ \begin{array}{l}
                1$ si $v = w\\
		0$ sinon$
               \end{array}\right.
\end{array} \right.$\\
On a montré que $\forall w \in W$,

$\F, w \models p \to \Diamond p$ ssi $\F[x \leftarrow w] \models x   \Ro x$.\\
On a aussi:$
\begin{array}{ll}
 \F \models p \to \Diamond p &$ ssi $\forall w, \F[x\leftarrow w] \models x  \Ro x\\
			    &$ ssi $\F \models \forall x, x  \Ro x 
\end{array}
$
\end{ex}
Algo pour trouver l'équivalent 1\ier ordre sur les cadres de $\chi \rightarrow POS$: \\
1)Traduire $\chi \rightarrow POS$ en second ordre de la forme\\
$\forall \vec p, \forall \vec y, [(REL \wedge BOX) \leftarrow ST_x(POS)$
où $
\begin{array}{l}
 RES$ est une conjonction de $y_i   \Ro_k y_j \;\; x   \Ro_k y_i\\
 BOX$ est une conjonction de la forme $\forall s, y_i R_{\beta} s \leftarrow p(s)
\end{array}$


2) Retourne la formule $\forall \vec y, REL \rightarrow ST_x(POS)$ dans laquelle on a remplacé les occurences de $p$ par 
$\sigma(p)=\lambda a . y_{i_1} R_{\beta_1} a \vee \cdots \vee y_{i_k} R_{\beta_k} a$\\
où chaque $y_{i_j} R_{\beta_j} a$ provient d'une formule $\forall s \; y_{i_j} R_{\beta_j} s \rightarrow p(s)$ qui apparaît dans BOX.

\section{Théorème de complétude}

Soit S un ensemble de formules . On écrit $\vdash_S \Phi$ pour dire que $\Phi$ est prouvable en utilisant 
\begin{itemize}
 \item les tautologies
 \item l'axiome K
 \item les instances de formules de S
 \item le modus ponens
 \item la nécéssitation
\end{itemize}
\begin{rem}
% $\vdash \Phi; \vdash_{\empty} \Phi$

De la même façon, on définit :

$\Sigma \vdash_S \Phi$ ssi $\exists \Psi_1, \dots, \Psi_n \in \Sigma \tq[s] \vdash_S ( \Psi_1 \wedge \dots \wedge \Psi_n) \rightarrow \Phi$.\\
Soit $\mathcal{C}$ une classe de cadres:
\begin{itemize}
 \item $\models_{\mathcal{C}} \Phi$ ssi $\forall \F \in \mathcal{C}, \F \models \Phi$.
 \item $\Sigma \models_{\mathcal{C}} \Phi$ ssi pour tout modèle $\mathcal{M}, w$ basé sur un cadre de $\mathcal{C}$, on a :\\
$\mathcal{M}, w \models \Sigma \Rightarrow \mathcal{M}, w \models \Phi$
\end{itemize}
\end{rem}

\begin{thm}[de complétude de Sahlquist]
Soit $S$ un ensemble de formules de Sahlquist, soit $C_s$ la classe de cadres qui vérifient les propriétés du 1er ordre correspondantes aux formules de $S$ sur les cadres.

On a:  $\Sigma \vdash_S \Phi$ ssi $\Sigma \models_{\mathcal{C}} \Phi$ (complétude forte).
\end{thm}
\begin{rem} [complétude faible]
$\vdash_S \Phi$ ssi $\models_S \Phi$.
\end{rem}

\part{Trois techniques pour montrer la décidabilité/compléxité du problème SAT de logique modale}
\section{cf TD}

\subsection{Logique modale S5}
\begin{tabular}{c |  c  }
 axiomatique & propriété sur les cadres \\
 $\Box p \leftarrow p$ & réfléxivité\\
 $\Box p \leftarrow \Box \Box p$ & transitivité\\
 $\lnot\Box p \Box \lnot \Box p$ & euclidianité\\
 $(\Diamond \Box p \leftarrow \Box p)$\\
\end{tabular}
\subparagraph{Application : } Logique epistémique

euclidianité : $\forall x, y, z, (x R y \wedge xRz) \leftarrow y R z$

\begin{prop}
 Si $R$ est réfléxive, transitive, alors $R$ euclidienne ssi $R$ symétrique
\end{prop}
\begin{prop}
$\begin{array}{ll}\\
             &\Phi$ satisfiable dans un modèle où R est une relation d'équivalence$ \\
\Leftrightarrow & \Phi$ satisfiable dans un modèle M = (W, R, V) où $R = W \times W
\end{array}$
\end{prop}
\begin{dem}
 \fbox{$\Leftarrow$} : trivial\\
\fbox{$\Rightarrow$} Si il existe $M, w$ où $\M  = (W, R, V)$ tq
\begin{itemize}
 \item $R$ est une relation d'équivalence
 \item $\M, w \models \Phi$
\end{itemize}
\end{dem}


\section{Méthodes de tableau (algo PSPACE)}
\begin{description}
 \item[KT] = logique des cadres réflexifs.
 \item[S5] = logique des cadres où R est une relation d'équivalence.
 \item[S4] = logique des cadres où R est réflexive et transitive.
\end{description}

On écrit les formules sous forme normale négative avec la logique suivante :\\
 $ \Phi := p  |  \lnot p  |  \bot  |  \top  |  \Phi \vee \Phi  |  \Phi \wedge \Phi  |  \Diamond \Phi  |  \Box \Phi $

\begin{definition}[ensemble de S4-Hintikka]
 Soit $\Sigma$ un sous-ensemble de formules en FNN clos par sous-formules. Un ensemble de S4-Hintikka H sur $\Sigma$ est un ensemble qui satisfait:
\begin{itemize}
 \item $H \subseteq \Sigma$
 \item $\perp \not \in H$
 \item $p \in H$ ssi $\lnot p \not \in H$
 \item Si $\Phi\vee\Psi \in H,$ alors $\Phi \in H$ ou $\Psi \in H$
  \item Si $\Phi\wedge\Psi \in H,$ alors $\Phi \in$ H et $\Psi \in H$
  \item Si $\Box \Phi \in H,$ alors $\Phi \in H$
\end{itemize}
On note $H^{\Box} = \{\Box \Psi \in H \}$
\end{definition}


Idée : Pour tester si $\Phi$ est S4-satisfiable, on appelle satS4$(\{\Phi\}, [\,])$

\begin{thm}
 L'appel S4$(\{\Phi\}, [\,])$ termine et utilise un espace polynomial en la taille de $\Phi$
\end{thm}
\begin{dem}
 Tous les $\Gamma$ des différents appels sont de la forme $\{\Psi\} \cup \Box)$

Invariant à chaque appel : 
\begin{itemize}
 \item Si $L = [ \Gamma_1, \cdots, \Gamma_k]$ alors $\Gamma_1^{\Box} \subseteq \cdots \subseteq \Gamma_k^{\Box} \subseteq \Gamma^{\Box}$
 \item chaque $\Gamma_i$ est de la forme $\Gamma_i^{\Box} \cup \{\Psi_i\}$
 \item Les éléments de L sont distincts
 \item Tous les ensembles ($\Gamma$, les $\Gamma_i$ sont des sous-ensembles de $SF(\Phi)$
\end{itemize}

But : $ | L |  \leq  | \Phi | ^2 +  | \Phi |  +1$
$\Gamma_1^{\Box} \subseteq \cdots \subseteq \Gamma_k^{\Box} \subseteq  SF(\Phi)$
$SF(\Phi)$ est de cardinal $ | \Phi | $ : il y a au plus $ | \Phi | $ inclusions strictes.

Soient $i_1, i_2, \dots$ les indices tq $\Gamma_{i_j-1}^{\Box} \varsubsetneq \Gamma_{i_j}^{\Box}$.\\
On a $i_{j+1} - i_j \leq  | \Phi | $ car sinon il y aurait deux fois la même formule $\Psi_i$ et donc 2 éléments de la liste L seraient égaux.

$k = \sum^J_{j=0} i_{j+1} - i_j \leq  | \Phi | ^2$
\end{dem}

\begin{thm}
 Si $\Phi$ est satisfiable, alors satS4$(\{\Phi\}, [\,])$ réussit
\end{thm}
\begin{dem}
 Par récurrence sur $ | \Phi | ^2 - L$, on montre que le sous-appel satS4$(\Gamma, L)$ réussit :\\
Si $\Gamma \in L$, l'appel réussit.\\
Sinon,$H = \{\Psi \in SF(\Phi) \tq M, w \models \Psi \}$ et on considère l'exécution qui s'occupe de ce H là.\\
Pour tout $\Diamond \Psi \in H, \; \{ \Psi \} \cup H^{\Box}$ est sat en $M,u$.\\
$\Rightarrow$ Par récurrence, les sous appels réussissent.\\
 $\Rightarrow$ Cet appel réussit.
\end{dem}

\begin{thm}
 Si satS4$(\{\Phi\}, [\,])$ réussit, alors $\Phi$ satisfiable.
\end{thm}

\begin{dem}
 \fbox{1} On montre que si  satS4$(\Gamma, L)$ réussit, alors il existe une structure $\mathcal{S} = (S, T, F)$ \tq[le]
\begin{itemize}
 \item $(S,T)$ est un ordre
 \item $F$ etiquette les noeuds de l'ordre avec des ensembles S4-Hintikka, et les feuilles sont étiquetées par des ensembles $\Gamma$ tels que
\begin{itemize}
 \item soit $\Gamma$ ne contient pas de $\Diamond \Psi_i$
 \item soit $\Gamma \in L$
 \item soit $\Gamma$ est inclus dans l'étiquette d'un label d'un prédécesseur
\end{itemize}
\item Si $\Box \Psi \in F(s)$, alors $t \in T(s), \Box \Psi \in F(t)$
\item Si $\Diamond \Psi \in F(s)$, alors $\exists t \in T(s),  \Psi \in F(t)$
\item La racine est étiquetée par un S4-hintikka incluant $\Gamma$
\end{itemize}
\fbox{2} On transforme $\mathcal{S} = (S, T, F)$ qui correspond à satS4$(\Gamma, [\,])$ en un modèle de Kripke.\\
Soit $\mathcal{M} = (W, R^*, V)$ défini par 
\begin{itemize}
 \item $W = S \setminus I$ où $I$ est l'ensemble des feuilles incluses dans un prédécesseur
 \item $R = T | _W \cup \{ (w,u) \in W$ tels qu'il existe $ l \in I \tq (w,l) \in T$ et $F(l) \subseteq F(u)$
 \item $V(p) =  \{w \in W, \tq[s] p \in F(w) \}$
 \item $R^*$ : fermeture réflexive et transitive de R
\end{itemize}
On montre par induction sur $\Phi \in SF(\Phi)$ que 

$\forall w \in W, \;\Psi \in F(w)$ ssi $\M,w \models \Psi$
\end{dem}

\begin{thm}
 S4-SAT est dans $PSPACE$
\end{thm}
\begin{thm}
 S4-SAT est $PSPACE$-hard
\end{thm}

\section{Filtration} 
But : Si $\M, w \models \Phi$, trouver $M^f, u \tq $
\begin{itemize}
 \item $M^f$ fini
 \item $M^f, u \models \Phi$
\end{itemize}

\begin{definition}
 Soit $\Phi$ une formule, soit $\M = (W, R, V)$. On définit $w \leftrightsquigarrow u$ ssi $\forall \Psi \in SF(\Phi),$
$M, w \models \Psi$ ssi $M, u \models \Phi$.\\
On dit que $M^f = (W^f, R^f, V^f)$ est une filtration si 
\begin{enumerate}
 \item $W = W_{ |  \leftrightsquigarrow}$
 \item Si $w   \Ro v$ alors $ | w |    \Ro^f  | v | $
 \item Si $ | w |    \Ro^f  | v | $ alors $\forall \Box \Psi \in SF(\Phi), $
	si $\M, w \models \Box \Phi$, alors $M,u \models \Psi$
\item $V^f(p) = \{ [ w  |  \in W^f \tq[s] \M,w \models p \}$ pour $p$ qui apparait dans $\Phi$
\end{enumerate}

\end{definition}

\begin{prop}
$ | W^f |  \leq 2^{ | \Phi | }$
\end{prop}
\begin{dem}$ \, \\
i:
\begin{array}{lcl}
 W^f & \rightarrow & 2^{SF(Phi)}\\
  | w |  & \mapsto&  \{ Psi \in SF(Phi) \tq \M, w \models Psi \}
\end{array}$
est bien définie et injective.
\end{dem}

\begin{thm}
 $\forall \Psi \in SF(Phi),\; \M,w \models \Psi$ ssi $M^f ,  | w |  \models \Psi$
\end{thm}
\begin{dem}
 par induction
\end{dem}

Logiques candidates pour la filtration : 
les logiques dont le problème SAT est NEXPTIME-complet.

Pour celles là, la filtration donne un algo optimal.
 

\part{Logiques temporelles}

\section{Présentation de $CTL^*$ et de ses fragments}
\subsection{Syntaxe}

Soit ATM un ensemble de propositions.

Le langage de $CTL^*$ est défini par:

$\Phi ::= \bot  |  p  |  \lnot \Phi  |  \Phi \vee \Psi  |   \Oo \Phi  |  F \Phi  |  \Go \Phi  |  \Phi \Uo \Phi  |  \exists \Phi  |  \forall \Phi$ où $p \in ATM$

Opérateurs temporels linéaires :
\begin{itemize}
 \item $ \Oo \Phi$ : au prochain instant, on a $\Phi$
 \item  $\Fo \Phi$ : un jour, $\Phi$ est vraie
 \item $\Go \Phi$ : $\Phi$ est toujours vraie
 \item $\Phi \Uo \Psi$ : $\Phi$ reste vraie jusqu'à ce que $\Psi$ le soit
\end{itemize}

Opérateurs de quantification sur les chemins : 
\begin{itemize}
 \item $\exists \Phi$ : il existe une exécution telle que $\Phi$
 \item $\forall \Phi$ : pour toute exécution, on a $\Phi$
\end{itemize}

\subsection{Sémantique}
Soit $\M = (W,R,V)$ un modèle de Kripke sériel ( $\forall w in W, R(w) \not = \empty$)

Un chemin $\Pi$ est une séquence infinie $\Pi_0 \Pi_1 \dots \tq[le] \forall i, \Pi_i \in W$ et $\Pi_i   \Ro \Pi_{i+1}$

\begin{definition}
 On définit $M, \Pi \models \Phi$ par induction sur $\Phi$ :
\begin{itemize}
 \item $\M, \Pi \models p$ ssi $\Pi_0 \in V(p)$
 \item $\M, \Pi \models  \Oo \Phi$ ssi $\M, \Pi [ 1 \dots ] \models \Phi$
 \item $\M, \Pi \models \Fo \Phi$ ssi $\exists i \geq 0 \tq \M, \Pi [ i \dots ] \models \Phi$
 \item $\M, \Pi \models \Go \Phi$ ssi $\forall i \geq 0 \tq \M, Pi [ i \dots ] \models \Phi$
 \item $\M, \Pi \models \Phi \Uo \Psi$ ssi \\$\exists i \geq 0 \tq \M, \Pi [ i \dots ] \models \Psi$ et $\forall j < i, M, \Pi[j \dots] \models \Phi$
 \item $\M, \Pi \models \forall \Phi$ ssi \\pour tout chemin $\Pi'$ dans $\M \tq \Pi'_0 = \Pi_0,$ on a $\M, \Pi' \models \Phi$
 \item $\M, \Pi \models \forall \Phi$ ssi \\il existe un chemin $\Pi'$ dans $\M \tq \Pi'_0 = \Pi_0$ et $\M, \Pi' \models \Phi$
\end{itemize}
On définit aussi :
\begin{itemize}
 \item $\M, s \models_{\forall} \Phi$ ssi pour tout chemin $\Pi \tq \Pi_0 = s,$ on a $\M, \Pi \models \Phi$
 \item $\M, s \models_{\exists} \Phi$ ssi il existe un chemin $\Pi \tq \Pi_0 = s,$ on a $\M, \Pi \models \Phi$
\end{itemize}

\end{definition}

\subsection{Fragments syntaxiques}
\begin{itemize}
 \item $LTL$ : formules sans $\exists$ ni $\forall$
 \item $CTL$ : formules où tout opérateur temporel ($  \Oo, \Fo, \Go, \Uo$) est précédé d'un opérateur $\exists$ ou $\forall$
\end{itemize}
\begin{ex}[pour CTL]
 $\forall \Fo p \exists ( \forall \Fo q \Uo \exists \Go q)\\
 $\st{$ \forall  \Oo p \wedge  \Oo  \Oo p)$}
\end{ex}

\section{LTL : Logique temporelle linéaire}

\begin{prop}
 Avec $LTL$, on n'arrive pas à dire \og $p$ est vraie dans les états $\Pi_{2k}$ où $k \in \Ns$\fg en n'utilisant qu'une seule variable.
\end{prop}

\begin{definition}[Axiomatisation de $LTL$]
 \begin{itemize}
  \item axiomes :
\begin{itemize}
 \item tautologies du calcul propositionnel
 \item $\Fo p \leftrightarrow \lnot \Go \lnot p$
 \item $ \Oo ( p \rightarrow q) \rightarrow (  \Oo p  \Oo q)$ (axiome K pour $ \Oo$)
 \item $\Go ( p \rightarrow q) \rightarrow ( \Go p \Go q) $ (axiome K pour $\Go$)
 \item $ \Oo p \leftrightarrow \lnot  \Oo \lnot p$
 \item $\Go p \leftrightarrow p \wedge  \Oo \Go p$
 \item $\Go ( p \rightarrow  \Oo p) \rightarrow (p \rightarrow \Go p)$ (induction)
 \item $p \Uo q \leftrightarrow q \vee (p \wedge  \Oo (p \Uo q))$
 \item $p \Uo q \rightarrow \Fo q$
\end{itemize}
\item règles :
\begin{itemize}
 \item modus ponens
 \item $\dfrac{\Phi}{ \Oo \Phi} \dfrac{\Phi}{\Go \Phi}$
\end{itemize}
 \end{itemize}
\end{definition}

\begin{definition}[Satisfiabilité pour $LTL$]
Ici, un chemin $\Pi$ est considéré comme un mot sur $2^{ATM}$

Le problème de satisfiabilité est défini par
\begin{description}
 \item [entrée] : formule $\Phi$ de $LTL$
 \item[sortie] : oui ssi $\exists \Pi \tq \Pi \models \Phi$
\end{description}
\end{definition}

\begin{prop}
 Soit $\Phi$ une formule satisfiable, $\exists \Pi \tq \Pi \models \Phi$
On note $[i]_{\Pi} = \{\Psi \in SF(\Phi) \tq \Pi[i \dots] \models \Psi \}$
\end{prop}

\begin{lem}[1]
 Si $i < j$ et $[i]_{\Pi} = [j]$, on définit $\Pi' = \Pi_0 \dots \Pi_{i-1} \Pi_j \Pi_{j+1} \dots$. On a alors 
$\forall k \in \Ns \setminus { i \dots j-1}, [k]_{\Pi} = [k]_{\Pi'}$
\end{lem}
\begin{dem}
 Par induction sur les formules.
\end{dem}
\begin{definition}
 Soit $\infty_{\Pi}$ l'ensemble des $S \subseteq SF(\Phi)$ tels qu'il existe une infinité de $k \tq[s] [k]_{\Pi} = S$. On dira qu'un chemin $\Pi$ est ultimement périodique à partir de $i$ et de période $p$ ssi $\forall k \geq i$, on a $\Pi_k = \Pi_{k+p}$
\end{definition}

\begin{lem}[2]
 Soient $i, p \in \Ns \tq[s] [i]_{\Pi} = [i+p]_{\Pi}$ et $\forall S \in \infty_{\Pi}, \exists k \in \{i, \dots, i+p-1 \} \tq[s] [k]_{\Pi} = S$.\\
Soit $\Pi'$ le chemin ultimement périodique à partir de $i$ et de période $p$, défini par $\forall k < i+p, \Pi'_k = \Pi_k$.\\
On a : $\forall k < i+p, [k]_{\Pi} = [k]_{\Pi'} et \forall k \geq i, [k]_{\Pi'} = [k+p]_{\Pi'}$
\end{lem}

\begin{thm}
 $\Phi$ est satisfiable ssi $\Phi$ satisfiable dans un chemin $\Pi$ ultimement périodique de point de départ $i$ et de période $p$ tels que $\begin{array}{ll}
    i \leq 2^{ | \Phi | }\\
    p \leq (2^{ | \Phi | })^2 = 4^{ | \Phi | }
 \end{array}$

\end{thm}


\begin{thm}
 LTL-SAT est PSPACE
\end{thm}


\begin{definition}
 Un ensemble de Hinikka sur $\Sigma$ est un ensemble saturé de la façon suivante :
\begin{itemize}
 \item $\Sigma \subseteq H$
 \item Si $\Phi \vee \Psi \in H, \quad \Phi \in H$ ou $\Psi \in H$
 \item Si $\lnot (\Phi \vee \psi) \in H, \quad \Phi \not \in H$ et $\Psi \not \in H$
 \item Si $\lnot \lnot \Phi \in H, \quad \Phi \in H$
 \item Si $\lnot \Oo \Psi \in H, \quad \Oo \lnot \Psi \in H$
 \item Si $\Psi \Uo \Phi \in H, \quad \Psi \in H$ ou $(\Phi \in H$ et $O (\Phi \Uo \Psi ) \in H$
 \item Si $\lnot (\Phi \Uo \Psi) \in H$
\end{itemize}

\end{definition}

\begin{thm}
 Model checking de $LTL$ est $PSPACE$-hard.
\end{thm}
\begin{thm}
 Le model checking de $LTL$ est réductible en temps polynomial à $LTL-SAT$.
\end{thm}
\begin{thm}
 Le model checking de $LTL$ est dans $PSPACE$.
\end{thm}
\begin{cor}
 $LTL-SAT$ est $PSPACE$-hard (et du coup $PSPACE$-complet).
\end{cor}

\begin{thm}
 Le model checking de $CTL^*$ est $PSPACE$-complet.
\end{thm}

\begin{thm}
 Le model checking de $CTL$ est dans $P$
\end{thm}



\begin{rem}

$\begin{array}{ll}
  $Si $\Phi$ est une formule de $CTL, \quad \M, \Pi \models \Phi & $ ssi $\M, \Pi_0 \models_{\exists} Phi\\
 & $ ssi $\M, \Pi_0 \models_{\forall} Phi
\end{array}$


\end{rem}

\begin{thm}
 Le model checking de $CTL$ sur $\M = W,R,V$ et $\Phi$ prend $O(|\Phi|  \times ( | X| + |R|))$ opérations.
\end{thm}

\begin{ex}
 $\Phi_G = \bigvee_{\sigma\text{ permutation de }1 n} \Phi_\sigma$
où $\phi_{\sigma}$ = 
\end{ex}




\begin{thm}
 Si on arrive à trouver une formule alternative $\Phi$ pour $\Phi_G$ de taille polynomiale alors $P = NP$
\end{thm}

\part{Expressivité}

\section{Comparaison de $LTL, CTL, CTL^*$}

\begin{definition}
 Soient $\Phi_1, \Phi_2$ deux formules de $CTL^*$.\\
$\Phi_1$ equivalente à $\Phi_2$ ssi pour tout modèle $\M,s$, on a 
	    $\M,s \models_\forall \Phi_1$ ssi $\M,s \models_\forall \Phi_2$

\end{definition}

\begin{thm}
 Soit $\Phi$ une formule de $CTL^*$.
\begin{itemize}
 \item Soit $\Phi$ est equivalente à $\Psi$ où $\Psi$ est $\Phi$ dans laquelle on a retité les quantificateurs de chemin $\exists, \forall$.
 \item Soit $\Phi$ n'est équivalente à aucune formule de $LTL$.
\end{itemize}

\end{thm}

\begin{lem}
$\forall n, \forall M,
 \forall \Phi LTL,$ si $\Phi \leq n, \exists x, y \subseteq \Pi \tq[s]$

$\M, \Pi \models \Phi$ ssi $\M, xy^\omega \models \Phi$
\end{lem}
\pagebreak
\begin{dem}[du théorème]
 Supposons $\Phi$ equivalent à $\chi$ formmule de $LTL$. \\
 Montrons que $\Phi$ est équivalente à $\Psi$ du théorème.\\
$\begin{array}{ll}
 M,s \models_\exists \Phi & \ssi \forall \Pi$ qui part de $s$, on a $M, \Pi \models \chi \\
		     &  \ssi \forall \Pi' = wy^{\omega}$ qui part de $s$, on a $M, \Pi' \models \chi\\
		      & \ssi \forall \Pi' = wy^{\omega}$ qui part de $s$, on a $M^{\Pi'}, 0 \models \chi\\
		     & $ où $M^{\Pi'} = (W', R', V') $ avec $\begin{array}{l}
		                                     W' = {0, \dots |xy|}\\
						    R' = {(n, n+1) \tq n < |xy|} \cup {(|xy|, |x|)}\\
						   V'(i) = V(\Pi_i)\\
		                                       \end{array}\\
		     &  \ssi \forall \Pi' \dots,$ on a $M^{\Pi'}, 0 \models_\exists \Phi\\
		      & \ssi \forall \Pi' \dots,$ on a $M^{\Pi'}, 0 \models_\exists \Psi ($comme $M^\Pi$ déterministe, on peut supprimer les $\forall$ et $\exists$ de $\Phi)\\
		      & \ssi \forall \Pi' = x y ^{\omega}, M, \Pi' \models \Psi\\
		      & \ssi \forall \Pi$ chemin quelconque, $M, \Pi \models_\forall \Psi$ (en utilisant le lemme)$\\
\end{array}$
\end{dem}

\begin{ex}
 $\forall G, \forall F, p$ est équivalente à $G F p $
\end{ex}

\begin{thm}
 Il existe une formule $CTL$ qui n'a pas d'équivalent $LTL$.
(par exemple $\forall G  \exists F p$).
\end{thm}

\begin{dem}
 Si $\forall G \exists F p$ a un équivalent $LTL$, cela serait $G F p$.
$M, w \not \models_\forall G F p
M, w \not \models_\exists \forall G \exists F p$
\end{dem}

\begin{ex}
 $\forall F \forall G p$ n'a pas d'équivalent $LTL$.
\end{ex}

\begin{thm}
 Il existe une formule $LTL$ qui n'a pas d'équivalent $CTL$.
Par exemple $FGp$.
\end{thm}

Pour tout $n \in N,
M, n s_n \not \models \forall FGp
M'n, s'n \models_\forall F G p$

\begin{lem}
 $\forall n \in \Ns,$ pour toute formule de $CTL, \Phi \tq | \Phi | \leq n, Mn, sn \models \Phi ssi M'n s'n \models \Phi$
\end{lem}

\begin{thm}
 Il existe une formmule $CTL^*$ qui n'est équivalente ni à une formule de $LTL$, ni à une formmule de $CTL$.
Par exemple, $\forall F G p \vee \forall G \exists F q$.
\end{thm}

\subsection{Comparaison de CTL avec K et S4}

\begin{prop}
 Soit tr une traduction de K dans CTL définie par :
$\Tr(\Box \Phi) = \forall \Oo \Tr(\Phi)$\\
Alors si $M, w$ est un modèle, on a 
$M,w \models_K \Phi \ssi M,w \models_\forall,\exists \Tr(\Phi)$\\

$\begin{array}{cc}
 K & CTL\\
 \Box & \forall \Oo
 \\ \Diamond & \exists \Oo
\end{array}$
\end{prop}

\begin{prop}
  Soit tr une traduction de S4 dans CTL définie par
$tr(\Box \Phi ) = \forall G \Tr(\Phi)$.\\
Soient $M = (W, R ,V)$ et $M^* = (W, R^*, V)$ deux modèles.

$M* , w \models_S4 \Phi$ ssi $M,w \models \Tr(\Phi)$
\end{prop}

\subsection{Bisimulations}

\begin{definition}
 On dit que $M, \Pi$ et $M', \Pi'$ sont bissimilaires  ssi $\forall n \in \Ns, $

$M, \Pi_n \bisim M', \Pi_n'$
\end{definition}

\begin{prop}
 Soient $M, w \bisim M',w,$ soit $\Pi$ un chemin qui part de $w$ dans $M$.\\
 Alors il existe un chemin $\Pi'$ partant de $w' \tq M, \Pi \bisim M', \Pi'$.
\end{prop}
\begin{dem}
 
\end{dem}
\begin{prop}
 Si $M,\Pi \bisim M', \Pi'$ alors $\forall \Phi$ de $CTL^*$, on a 
$M, \Pi \models \Phi$ ssi $M', \Pi' \models \Phi$.
\end{prop}
\begin{dem}
 Par induction.
\end{dem}
\begin{thm}
 Soient $M,w$ et $M', w$' des modèles à images finies.
On a équivalence entre :
  \begin{enumerate}
   \item $M, w \bisim M', w'$
   \item $\forall \Phi \in CTL^*, \quad M,w \models_\exists \Phi$ ssi $M', w' \models_\exists \Phi$
   \item $\forall \Phi \in CTL,  \quad M,w \models_\exists \Phi$ ssi $M', w' \models_\exists \Phi$
  \end{enumerate}

\end{thm}


\part{Demain, toujours \dots et le problème SAT devient EXPTIME}

\section{Musée}

\subsection{Propositional Dynamic Logic}

\subsubsection{Syntaxe}
Soit $ATM$ un ensemble de propositions
Soit $PRG$ un ensemble de programmes atomiques

Le language de $PDL$ est le suivant : $
\begin{array}{ll}
 \Phi := p | \lnot \Phi | \Phi \vee \Phi | [\Pi] \Phi		&$où $p \in ATM \\
 \Pi := a | \Pi;\Pi | \Pi \cup \Pi | \Pi* | \Phi ?	&$où $a \in PRG
\end{array}$

\subsection{Sémantique}

On appelle $PROG$ l'ensemble des programmes.

\begin{definition}
 Un modèle $M = (W, (R_{\Pi})_{\Pi \in PROG}, V)$ est un modèle de $PDL$ si : 
\begin{itemize}
 \item $W$ est un ensemble de mondes
 \item $R_{\Psi ? }$ = $\{ (w,w) \in W², M, w \models \Phi\}$
 \item $R_{\Pi_1 ; \Pi_2} = R_{\Pi_1}\circ R_{\Pi_2}$
 \item $R_{\Pi_1 \cup \Pi_2} = R_{\Pi_1} \cup R_{\Pi_2}$
 \item $R_{\Pi^*} = (R_{\Pi})^*$ (cloture réflexive transitive)
\end{itemize}

\end{definition}

\begin{definition}
$ M,w \models [\Pi]$ ssi $\forall u \in R_{\Pi(w)},$ on a $M, u \models \Phi$
\end{definition}

\subsection{Connaissance commune}

\subsubsection{Syntaxe}

Soit $AGT$ un ensemble d'agents.

$\Phi := p | \lnot \Phi | \Phi \vee \Phi | K_j \Phi | CK_J \Phi$	où $j \in ATM, J \subseteq AGT$\\
$K_j \Phi$ = $j$ sait que $\Phi$\\
$CK_J \Phi$ = un groupe $J$ a la connaissance commune que $\Phi$\\

\subsubsection{Sémantique}

\begin{definition}
 
Un modèle $M$ pour cette logique est $(W, (R_j)_{j \in AGT }, V)$ où
\begin{itemize}
 \item $W$ est un ensemble non vide de mondes
 \item $\forall j, R_j$ est une relation d'équivalence
 \item $V$ est une valuation
\end{itemize}

\end{definition}


\begin{definition}
 $M, w \models K, \Phi \ssi \forall u \in R_j(w), M,u \models \Phi\\
 M, w \models CK_J \Phi \ssi \forall u \in (\bigcup_{j \in J} R_j)^*, M, u \models \Phi$
\end{definition}

\subsection{Conséquence globale dans K}

Jusqu'à présent, on a $\Sigma \models_C^{local} \Phi$ qui signifie : \\
pour tout modèle pointé $(M, w)$, on a:

$M, w \models \Sigma$ implique $M, w \models \Phi$.\\

On peut aussi introduire la conséquence globale : $\Sigma \models_C^{global} \Phi$ ssi pour tout modèle $M$ de $C, \\M \models \Sigma$ implique $M \models \Phi.$

\begin{rem}
 $\Sigma \models_K^{globale} \Phi \ssi \{ \Box^n \Psi \tq \Psi \in \Sigma, n \in \Ns \} \models_K^{local} \Phi$

$\Sigma' \models_{S4}^{globale} \Phi \ssi \{ \Box^n \Psi \tq \Psi \in \Sigma \} \models_{S4}^{local} \Phi$
\end{rem}

\begin{prop}
 Le problème suivant :
\begin{tabular}{l}
entrée : $\Sigma$ fini, $\Phi$\\
sortie : $\Sigma \models_{S4}^{globale} \Phi$
\end{tabular}
est $PSPACE$-complet
\end{prop}


\section{Machines alternantes}

\subsection{Définitions}

\begin{definition}
 Une machine de Turing alternante est $M = (Q, U, \delta, s)$ avec
\begin{itemize}
 \item $Q$ ensemble fini d'états
 \item $U \subseteq Q$ (états universels)
 \item $\delta \subseteq (Q \times \Sigma) \times (Q \cup \{no, yes \} \times \Sigma \times \{-1,0,1\}$
\end{itemize}
\end{definition}

\begin{definition}
Une configuration est un triplet $(q,k,w)$ où: 
\begin{itemize}
 \item $q$ est un état
 \item $k$ est une position
 \item $w$ not
\end{itemize}

\end{definition}

\subsection{Calculs}

$\mathcal{C}$ = ensemble de configurations.

\begin{definition}
 Un arbre de calcul de $M$ sur $x$ est un arbre (pt infini) tel que chaque noeud est une configuration et les enfants de $c$ sont les $c'$ tels que $c →^u c'$.\\
Formellement, $i$ est une fonction partielle de $\{0,1,\dots \} ^* → C$
\end{definition}

\begin{definition}
 Une étiquette : $\{0,1,\dots \} ^* → \{0,1\}$ d'un arbre $A$ est acceptante ssi 
\begin{itemize}
 \item $L(u) = 1$ si $A(u)$ est acceptante
 \item $\displaystyle L(u) = \bigvee_{n.k} L(n.k)$ si $A(u)$ est existentiel ($\exists$)
 \item $\displaystyle L(u) = \bigwedge_{n.k} L(n.k)$ si $A(u)$ est universel ($\forall$)
\end{itemize}
\end{definition}

\begin{definition}
 $M$ accepte $x$ ssi $L(\epsilon) = 1$ pour toute étiquette $L$ de l'unité de calcul où la configuration à la racine est $(s,0,x)$.
\end{definition}
\begin{rem}
 Il peut y avoir plusieurs étiquettes si l'arbre est infini.
\end{rem}

\begin{definition}
 $M$ accepte $L$ ssi $(x \in L \Leftrightarrow M$ accepte $x$).
\end{definition}

\begin{definition}
 $M$ accepte $L$ en temps $f$ ssi $M$ accepte $L$ et la profondeur de l'arbre issu de $(s,0,x)$ est de profondeur bornée par  $f(|x|)$ pour tout $x$.
\end{definition}

\begin{definition}
 $M$ accepte $L$ en espace $f$ ssi $M$ accepte $L$ et la taille des rubans des configurations de l'arbre issu de $(s,0,x)$ est de profondeur bornée par $f(|x|)$ pour tout $x$.
\end{definition}

\begin{definition}
 $AP$ = classe des langages reconnus par une MTA en temps polynomial.\\
$APSPACE$ = classe des langages reconnus par une MTA en espace polynomial.
\end{definition}

\subsection{Comparaison des classes de compléxité}

\begin{thm}
 $AP = PSPACE$
\end{thm}

\begin{thm}
$ APSPACE = EXPTIME$
\end{thm}


\end{document}
